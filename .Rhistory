listOfPackages <- c("plyr", "here", "sensitivity", "mvtnorm", "scales", "synchrony", "zoo",
"viridis", "ggplot2", "gsl", "dplyr", "Rcpp", "RcppArmadillo", "sn")
newPackages <- listOfPackages[!(listOfPackages %in% installed.packages()[ , "Package"])]
if (length(newPackages)) {
install.packages(newPackages)
}
lapply(listOfPackages, require, character.only = TRUE)
here <- here::here
simParF <- read.csv(here("data/manProcScenarios/fraserMPInputs_varyMixPpn.csv"), stringsAsFactors = F)
simParF <- read.csv(here("data/opModelScenarios/fraserOMInputs_varyCorr.csv"), stringsAsFactors = F)
cuPar <- read.csv(here("data/fraserCUpars.csv"), stringsAsFactors=F)
srDat <- read.csv(here("data/fraserRecDatTrim.csv"), stringsAsFactors=F)
catchDat <- read.csv(here("data/fraserCatchDatTrim.csv"), stringsAsFactors=F)
ricPars <- read.csv(here("data/fraserDat/rickerMCMCPars.csv"), stringsAsFactors=F)
larkPars <- read.csv(here("data/fraserDat/larkinMCMCPars.csv"), stringsAsFactors=F)
tamFRP <- read.csv(here("data/fraserDat/tamRefPts.csv"), stringsAsFactors=F)
cuCustomCorrMat <- read.csv(here("data/fraserDat/prodCorrMatrix.csv"), stringsAsFactors=F)
here()
set.seed(123)
#_______________________________________________________________________
## Set up input arguments
# Simulation parameters (biological, observation, and management)
nameOM <- simPar$nameOM
nameMP <- simPar$nameMP
plotOrder <- simPar$plotOrder
prod <- simPar$prodRegime #what is current prodRegime; requires list of posterior estimates for sampling
harvContRule <- simPar$harvContRule
species <- simPar$species #species (sockeye, chum, pink, coho)
simYears <- simPar$simYears #total length of simulation period
nTrials <- nTrials #number of trials to simulate
canER <- simPar$canER #baseline exploitation rate divided among mixed and single CU fisheries
ppnMixHigh <- simPar$propMixHigh #ppn of Canadian harvest allocated to mixed stock fisheries when abundance is high (default)
ppnMixLow <- simPar$propMixLow #as above, but when abundance is low; currently only relevant for TAM MPs
freqSkew <- simPar$freqSkew
varyAllocation <- simPar$varyAllocation #if TRUE then ppn of ER allocated to mixed stock fishery will switch to ppnMixLow when abundance is low (currently set at lower BM)
rho <- simPar$rho #autocorrelation coefficient in recruitment residuals
correlCU <- simPar$correlCU #correlation among CUs in recruitment deviations
adjSig <- simPar$adjustSig # used to scale CU specific sigma up or down
tauCatch <- simPar$tauCatch # CU-specific catch assignment error
obsSig <- simPar$obsSig #estimated spawner abundance error
mixOUSig <- simPar$mixOUSig #mixed fisheries outcome uncertainty error (same for canadian and US fisheries)
singOUSig <- simPar$singOUSig #single fisheries outcome uncertainty error; assumed to be same across CUs but could be varied
obsMixCatchSig <- simPar$obsMixCatchSig #estimated catch error in mixed-CU fisheries (same for canadian and US fisheries)
obsSingCatchSig <- simPar$obsSingCatchSig #estimated catch error in single CU fisheries
ageErr <- simPar$ageErr #error assigning recruits to a brood year
lowCatchThresh <- simPar$lowCatchThresh #area specific-BM representing minimum catch levels
highCatchThresh <- simPar$highCatchThresh
extinctThresh <- simPar$extinctThresh #minimum number of spawners before set to 0
### FOLLOWING WILL LIKELY BE REMOVED FOR INITIAL STUDY
obsSBias <- simPar$obsSBias #bias in spawner abundance estimates
strayRate <- simPar$strayRate #stray rate among CUs (set to 0)
propSampleCU <- simPar$propSampleCU #proportion of CUs sampled
sampleProb <- simPar$sampleProb #probability that a CU is sampled, eg if 0.5 then 50% probability a CU is removed
## CU-specific parameters
cuPar$stkName <- abbreviate(cuPar$stkName, minlength = 4)
if (species == "chum") {
larkPars <- NULL
}
cuPar <- with(cuPar, cuPar[order(as.numeric(stk)), ]) #temporary subset of CUs to examine
cuNameOM <- cuPar$nameOM
cuNameMP <- cuPar$nameMP
nCU <- nrow(cuPar) #number of CUs in analysis
stkName <- cuPar$stkName
stkID <- cuPar$stk
manUnit <- cuPar$manUnit #aggregate of CUs managed coherently
muName <- unique(manUnit)
nMU <- length(muName)
model <- cuPar$model #stock recruit model type (larkin, ricker)
domCycle <- cuPar$domCycle #which cycle line is dominant (for Larkin stocks only)
amER <- cuPar$usER #American exploitation rate shared
minER <- cuPar$minER #minimum exploitation rate applied with TAM rule even at low abundance
if (is.null(cuPar$medDBE)) {
enRouteMR <- rep(0, length.out = nrow(cuPar))
enRouteSig <- rep(0, length.out = nrow(cuPar))
} else { # FRASER ONLY; en-route mortality rate (i.e. between marine fisheries and terminal fisheries) taken from in-river difference between estimates (post-2000); replace NAs w/ 0s
enRouteMR <- cuPar$medDBE
enRouteSig <- cuPar$sdDBE
}
if (is.null(cuPar$medMA)) {
manAdjustment <- rep(0, length.out = nrow(cuPar))
} else { #management adjustment to increase escapement goal based on median MU-level observations of pDBE since 2000
manAdjustment <- cuPar$medMA
}
forecastMean <- cuPar$meanForecast
forecastSig <- cuPar$sdForecast
ageStruc <- matrix(c(cuPar$meanRec2, cuPar$meanRec3, cuPar$meanRec4, cuPar$meanRec5, cuPar$meanRec6), nrow=nCU, ncol=5) #mean proportion of each age class in returns
nAges <- ncol(ageStruc) #total number of ages at return in ageStruc matrix (does not mean that modeled populations actually contain 4 ages at maturity)
tauAge <- cuPar$tauCycAge #
medAbundance <- cbind(cuPar$medianRec, cuPar$lowQRec, cuPar$highQRec) #matrix of long term abundances (median, lower and upper quantile)
recCap <- 5 * cuPar$highQRec #default recruitment cap; if TS available will use 3x max obs (in following loop)
#Temporary inputs
## Input values from external .csv files for testing function components
## SOCKEYE PARS
# simParF <- read.csv(here("data/manProcScenarios/fraserMPInputs_varyMixPpn.csv"), stringsAsFactors = F)
simParF <- read.csv(here("data/opModelScenarios/fraserOMInputs_varyCorr.csv"), stringsAsFactors = F)
cuPar <- read.csv(here("data/fraserCUpars.csv"), stringsAsFactors=F)
srDat <- read.csv(here("data/fraserRecDatTrim.csv"), stringsAsFactors=F)
catchDat <- read.csv(here("data/fraserCatchDatTrim.csv"), stringsAsFactors=F)
ricPars <- read.csv(here("data/fraserDat/rickerMCMCPars.csv"), stringsAsFactors=F)
larkPars <- read.csv(here("data/fraserDat/larkinMCMCPars.csv"), stringsAsFactors=F)
tamFRP <- read.csv(here("data/fraserDat/tamRefPts.csv"), stringsAsFactors=F)
cuCustomCorrMat <- read.csv(here("data/fraserDat/prodCorrMatrix.csv"), stringsAsFactors=F)
# selectedCUs <- c("E. Stuart", "Bowron", "Chilko", "L. Shuswap", "Cultus", "Harrison")
# cuPar <- cuPar[cuPar$stkName %in% selectedCUs, ]
# cuPar <- subset(cuPar, model == "larkin")
## CHUM PARS
# simParF <- read.csv(here("data/opModelScenarios/nassOMInputs_varyCorr.csv"), stringsAsFactors=F)
# cuPar <- read.csv(here("data/nassCUpars.csv"), stringsAsFactors=F)
# srDat <- read.csv(here("data/nassRecDatTrim.csv"), stringsAsFactors=F)
# catchDat <- read.csv(here("data/nassCatchDatTrim.csv"), stringsAsFactors=F)
# ricPars <- read.csv(here("data/northCoastDat/nassChumMCMCPars.csv"), stringsAsFactors=F)
## Misc. objects to run single trial w/ "reference" OM
uniqueProd <- TRUE
variableCU <- FALSE #only true when OM/MPs vary AMONG CUs (still hasn't been rigorously tested)
dirName <- "varyTAM_sockeye"
nTrials <- 5
simPar <- simParF[5, ]
multipleMPs <- TRUE #only false when running scenarios with multiple OMs and only one MP
simPar
set.seed(123)
#_______________________________________________________________________
## Set up input arguments
# Simulation parameters (biological, observation, and management)
nameOM <- simPar$nameOM
nameMP <- simPar$nameMP
plotOrder <- simPar$plotOrder
prod <- simPar$prodRegime #what is current prodRegime; requires list of posterior estimates for sampling
harvContRule <- simPar$harvContRule
species <- simPar$species #species (sockeye, chum, pink, coho)
simYears <- simPar$simYears #total length of simulation period
nTrials <- nTrials #number of trials to simulate
canER <- simPar$canER #baseline exploitation rate divided among mixed and single CU fisheries
ppnMixHigh <- simPar$propMixHigh #ppn of Canadian harvest allocated to mixed stock fisheries when abundance is high (default)
ppnMixLow <- simPar$propMixLow #as above, but when abundance is low; currently only relevant for TAM MPs
freqSkew <- simPar$freqSkew
varyAllocation <- simPar$varyAllocation #if TRUE then ppn of ER allocated to mixed stock fishery will switch to ppnMixLow when abundance is low (currently set at lower BM)
rho <- simPar$rho #autocorrelation coefficient in recruitment residuals
correlCU <- simPar$correlCU #correlation among CUs in recruitment deviations
adjSig <- simPar$adjustSig # used to scale CU specific sigma up or down
tauCatch <- simPar$tauCatch # CU-specific catch assignment error
obsSig <- simPar$obsSig #estimated spawner abundance error
mixOUSig <- simPar$mixOUSig #mixed fisheries outcome uncertainty error (same for canadian and US fisheries)
singOUSig <- simPar$singOUSig #single fisheries outcome uncertainty error; assumed to be same across CUs but could be varied
obsMixCatchSig <- simPar$obsMixCatchSig #estimated catch error in mixed-CU fisheries (same for canadian and US fisheries)
obsSingCatchSig <- simPar$obsSingCatchSig #estimated catch error in single CU fisheries
ageErr <- simPar$ageErr #error assigning recruits to a brood year
lowCatchThresh <- simPar$lowCatchThresh #area specific-BM representing minimum catch levels
highCatchThresh <- simPar$highCatchThresh
extinctThresh <- simPar$extinctThresh #minimum number of spawners before set to 0
### FOLLOWING WILL LIKELY BE REMOVED FOR INITIAL STUDY
obsSBias <- simPar$obsSBias #bias in spawner abundance estimates
strayRate <- simPar$strayRate #stray rate among CUs (set to 0)
propSampleCU <- simPar$propSampleCU #proportion of CUs sampled
sampleProb <- simPar$sampleProb #probability that a CU is sampled, eg if 0.5 then 50% probability a CU is removed
## CU-specific parameters
cuPar$stkName <- abbreviate(cuPar$stkName, minlength = 4)
if (species == "chum") {
larkPars <- NULL
}
cuPar <- with(cuPar, cuPar[order(as.numeric(stk)), ]) #temporary subset of CUs to examine
cuNameOM <- cuPar$nameOM
cuNameMP <- cuPar$nameMP
nCU <- nrow(cuPar) #number of CUs in analysis
stkName <- cuPar$stkName
stkID <- cuPar$stk
manUnit <- cuPar$manUnit #aggregate of CUs managed coherently
muName <- unique(manUnit)
nMU <- length(muName)
model <- cuPar$model #stock recruit model type (larkin, ricker)
domCycle <- cuPar$domCycle #which cycle line is dominant (for Larkin stocks only)
amER <- cuPar$usER #American exploitation rate shared
minER <- cuPar$minER #minimum exploitation rate applied with TAM rule even at low abundance
if (is.null(cuPar$medDBE)) {
enRouteMR <- rep(0, length.out = nrow(cuPar))
enRouteSig <- rep(0, length.out = nrow(cuPar))
} else { # FRASER ONLY; en-route mortality rate (i.e. between marine fisheries and terminal fisheries) taken from in-river difference between estimates (post-2000); replace NAs w/ 0s
enRouteMR <- cuPar$medDBE
enRouteSig <- cuPar$sdDBE
}
if (is.null(cuPar$medMA)) {
manAdjustment <- rep(0, length.out = nrow(cuPar))
} else { #management adjustment to increase escapement goal based on median MU-level observations of pDBE since 2000
manAdjustment <- cuPar$medMA
}
forecastMean <- cuPar$meanForecast
forecastSig <- cuPar$sdForecast
ageStruc <- matrix(c(cuPar$meanRec2, cuPar$meanRec3, cuPar$meanRec4, cuPar$meanRec5, cuPar$meanRec6), nrow=nCU, ncol=5) #mean proportion of each age class in returns
nAges <- ncol(ageStruc) #total number of ages at return in ageStruc matrix (does not mean that modeled populations actually contain 4 ages at maturity)
tauAge <- cuPar$tauCycAge #
medAbundance <- cbind(cuPar$medianRec, cuPar$lowQRec, cuPar$highQRec) #matrix of long term abundances (median, lower and upper quantile)
recCap <- 5 * cuPar$highQRec #default recruitment cap; if TS available will use 3x max obs (in following loop)
## Stock-recruitment data
if (exists("srDat")) { #transform rec data if available
firstYr <- min(srDat$yr)
if (exists("catchDat")) { #add catch data if available
recDat <- Reduce(function(x, y) merge(x, y, by = c("stk", "yr")), list(catchDat, srDat)) #catchDat comes first so that recruits can be pulled out regardless of dataframe width
} else{
recDat <- srDat
}
recDat <- recDat[recDat$stk %in% cuPar$stk, ] #remove stocks from SR dataset that aren't in CU parameter inputs
if (length(unique(recDat$stk)) != length(unique(cuPar$stk))) {
stop("SR input dataset does not match parameter inputs")
}
recDat <- with(recDat, recDat[order(stk, yr),])
recDat$totRec <- apply(recDat[, c("rec2", "rec3", "rec4", "rec5", "rec6")], 1, sum)
summRec <- recDat %>%
group_by(stk) %>%
summarise(tsLength = length(ets), maxRec = max(totRec, na.rm = TRUE))
nPrime <- max(summRec[, "tsLength"])
recCap <- 3 * summRec$maxRec
dumFull <- vector("list", nCU)
stkList <- unique(cuPar$stk) #list of stk numbers to pass to following for loop; only necessary when using a subset of CUs from input
for (k in 1:nCU) { #add NAs to front end of shorter TS to ensure all matrices are same length in SR list
dum <- recDat[recDat$stk == stkList[k], ]
if (nrow(dum) < nPrime) {
empties <- nPrime - nrow(dum)
emptyMat <- matrix(NA, nrow = empties, ncol = ncol(recDat))
colnames(emptyMat) <- colnames(dum)
dum <- rbind(emptyMat, dum)
}
dumFull[[k]] <- dum
}
recDat <- dumFull
}
## Stock-recruitment parameters
ricA <- cuPar$alpha
ricB <- cuPar$beta0
ricSig <- cuPar$sigma
if (species == "sockeye") {
larA <- cuPar$larkAlpha
larB <- cuPar$larkBeta0
larB1 <- cuPar$larkBeta1
larB2 <- cuPar$larkBeta2
larB3 <- cuPar$larkBeta3
larSig <- cuPar$larkSigma
}
if (uniqueProd == FALSE) { #coerce all stocks to have the same alpha parameter (regardless of model structure), others will vary
ricA <- rep(mean(cuPar$alpha), length.out = nCU)
larA <- rep(mean(cuPar$alpha), length.out = nCU)
ricSig <- rep(mean(cuPar$sigma), length.out = nCU)
larSig <- rep(mean(cuPar$sigma), length.out = nCU)
}
if (prod != "med" & is.null(ricPars) == TRUE) {
stop("Full SR parameter dataset necessary to simulate alternative productivity scenarios")
}
if (is.null(ricPars) == FALSE) { #change from median values if .csv of par dist is passed
dum <- getSRPars(pars = ricPars, alphaOnly = TRUE, highP = 0.95, lowP = 0.05,
stks = stkID) #following code could be pulled from here and added to getSRPars()
if (prod == "low") {
srPars <- dum$pLow
}
if (prod == "med" | prod == "skew") {
srPars <- dum$pMed
}
if (prod == "high") {
srPars <- dum$pHigh
}
if (prod == "decline") {
srPars <- dum$pMed
finalRicA <- as.numeric(dum$pLow[["alpha"]]) #floor value to which A declines equals lower probabily
}
ricA <- srPars[["alpha"]]
ricB <- srPars[["beta0"]]
ricSig <- srPars[["sigma"]]
if (is.null(larkPars) == FALSE) {
dum <- getSRPars(pars = larkPars, alphaOnly = TRUE, highP = 0.95, lowP = 0.05,
stks = stkID)
if (prod == "low") {
srParsLark <- dum$pLow
}
if (prod == "med" | prod == "skew") {
srParsLark <- dum$pMed
}
if (prod == "high") {
srParsLark <- dum$pHigh
}
if (prod == "decline") {
srParsLark <- dum$pMed
finalLarA <- as.numeric(dum$pLow[["alpha"]]) #floor value to which A declines
}
larA <- (srParsLark[["alpha"]])
larB <- (srParsLark[["beta0"]])
larB1 <- (srParsLark[["beta1"]])
larB2 <- (srParsLark[["beta2"]])
larB3 <- (srParsLark[["beta3"]])
larSig <- (srParsLark[["sigma"]])
}
}
load_all()
devtools::load_all(".")
devtools::load_all(".")
?build
?document
