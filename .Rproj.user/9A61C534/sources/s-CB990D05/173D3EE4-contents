#' Calculate performance metrics 
#'
#' This function calculates specific performance metrics from observed data so that they can be 
#' compared to forward simulated values.
#'
#' This is a quasi-generic function. Although it does not depend on other samSim outputs, the 
#' input data must be structured in a very specific way (based upon Fraser River stock-recruit
#' datasets)
#'
#' @importFrom dplyr group_by mutate select summarise
#' @importFrom gsl lambert_W0
#'
#' @param dirName A character vector describing directory where output data saved.
#' @param subDirName A character vector describing subdirectory where output data saved.
#'  Defaults to NULL.
#' @param selectedCUs A character vector of CUs that will be subsetted from aggregate. Defaults
#'  to NULL.
#' @param agg Is the generated list summarizing aggregate or CU-specific data? Defaults to TRUE.
#' @param aggTS If agg == TRUE, is the generated list summarizing aggregate time series data?
#'  Defaults to FALSE.
#'
#' @return Returns a list of subdirectory outputs within the directory.
#'
#' @examples
#'
#' @export


## This function generates estimates of current PMs using SR parameters, escapement, and catch
# data
# NOTE 1: rec/spwnr/catch PMs based on last 20 yrs of data; SR par PMs based on full TS (due to 
# how alpha and beta are estimated)
# NOTE 2: Current SR parameter outputs are based on Ricker model ONLY 
genCurrentPMs <- function(srDat, catchDat, parDat, years = 20){
  
  ##SR data 
  srDat$rec <- apply(srDat[, c("rec2", "rec3", "rec4", "rec5", "rec6")], 1, sum)
  srTrim <- srDat %>% 
    select(stk, yr, ets, rec) %>%
    mutate(stk = as.factor(stk))
  agTrim <- srDat %>% #calculate aggregate recruits and spawners
    group_by(yr) %>%
    summarise(sumS = sum(ets, na.rm = T),
              sumRecBY = sum(rec, na.rm = T))
  agD <- data.frame(stk = "agg", #reshape to be same dimensions as original SR dat
                    yr = unique(srTrim$yr),
                    ets = agTrim$sumS,
                    rec = agTrim$sumRecBY)
  agDTail <- tail(agD, n = years) #take last n years of data only (ensures PMs are relevant and )
  srPMs <- rbind(srTrim, agDTail) #combine
  srPMs <- srPMs %>% #calculate performance metrics
    group_by(stk) %>% 
    summarise(meanS = mean(ets, na.rm = T),
              varS = cv(ets),
              meanRecBY = mean(rec, na.rm = T),
              varRecBY = cv(rec))
  
  ##catch data
  trimCatch <- catchDat %>% #clean catch data
    select(stk, yr, totCatch) %>%
    mutate(stk = as.factor(stk))
  agCatch <- catchDat %>% #calculate aggregate catch
    group_by(yr) %>%
    summarise(totCatch = sum(totCatch)) %>%
    mutate(stk = "agg")
  agCatch$stk <- as.factor(agCatch$stk)
  agCatch <- tail(agCatch, n = years) #trim to last n years
  temp <- rbind(trimCatch, agCatch[, c(3, 1, 2)])
  catchPMs <- temp %>%
    group_by(stk) %>%
    summarise(meanCatch = mean(totCatch, na.rm = T),
              varCatch = cv(totCatch))
  
  ##benchmarks based on SR parameters
  parDat <- parDat %>% 
    mutate(sMSY = (1 - lambert_W0(exp(1 - alpha)))/beta0, sGen = NA) %>%
    select(stk, alpha, beta0, sigma, sMSY, sGen)
  for (i in seq_along(parDat$stk)) {
    spwnrs <- subset(srDat, stk == i)$ets
    parDat$sGen[i] <- as.numeric(solver.sgen(spwnrs, 
                                             theta = c(parDat$alpha[i], parDat$alpha[i]/parDat$beta0[i], parDat$sigma[i]), 
                                             parDat$sMSY[i]))
  }
  agPM <- data.frame(stk = "agg", #calculate aggregate benchmarks
                     sMSY = sum(parDat$sMSY),
                     sGen = sum(parDat$sGen))
  parPMs <- rbind(parDat[, c("stk", "sMSY", "sGen")], agPM)
  parPMs$ppnYrsLower <- NA
  parPMs$ppnYrsUpper <- NA
  countLowBM <- rep(0, length.out = nrow(parPMs))
  countUpBM <- rep(0, length.out = nrow(parPMs))
  for (i in seq_along(parPMs$stk)) {
    if (parPMs$stk[i] == "agg") { #pull agg spawner TS from above
      spwnrs <- agD$ets
    } else {
      spwnrs <- subset(srDat, stk == i)$ets
    }               
    parPMs$ppnYrsLower[i] <- length(spwnrs[spwnrs > parPMs$sGen[i]]) / length(spwnrs)
    parPMs$ppnYrsUpper[i] <- length(spwnrs[spwnrs > parPMs$sMSY[i]]) / length(spwnrs)
    if (mean(tail(spwnrs, n = 12)) > parPMs$sGen[i]) { #if mean abundance over 3 gens greater than BM counter goes up
      countLowBM[i] <- 1
    }
    if (mean(tail(spwnrs, n = 12)) > parPMs$sMSY[i]) {
      countUpBM[i] <- 1
    }
  }
  parPMs$ppnCULower <- sum(countLowBM) / (length(parPMs$stk) - 1) #subtract one to account for agg level
  parPMs$ppnCUUpper <- sum(countUpBM) / (length(parPMs$stk) - 1) #subtract one to account for agg level
  
  currentPMs <- Reduce(function(x, y) merge(x, y, by = "stk"), list(srPMs, catchPMs, parPMs))
  currentPMs <- with(currentPMs, currentPMs[order(stk), ])
  names(currentPMs)[c(1:3)] <- c("stkNumber", "meanSpawners", "varSpawners")
  return(currentPMs)  
}