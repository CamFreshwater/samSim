#*************************************************************************************
# postProcessing.R
# Date revised: March 22, 2018; ONGOING
# Author: C. Freshwater
# Explainer: Functions used to generate outputs from multiple runs of recoverySim.R
#*************************************************************************************

# Check if required packages are installed and run
listOfPackages <- c("gplots", "viridis", "tidyr", "ggplot2")
newPackages <- listOfPackages[!(listOfPackages %in% installed.packages()[ , "Package"])]
if(length(newPackages)) install.packages(newPackages)
lapply(listOfPackages, require, character.only = TRUE)

select <- dplyr::select

#_______________________________________________________________________________________
#### HELPER FUNCTIONS ####
#_______________________________________________________________________________________

# Generates double CI plots with shading proportional to categorical variables
tradeoffPlot <- function(X, Y, xInterval, yInterval, cols="black", colAlpha, pch = 21, cex = 1.2){
  plot(X, Y, col="black", pch = pch, bg = alpha(cols, colAlpha), ylab="", xlab="", cex = cex,
       ylim = c(0, max(Y + yInterval)), xlim = c(0, max(X + xInterval)))
  for(i in seq_along(xInterval)){
    if(yInterval[i]>0.001){
      arrows(X[i],
             Y[i]+yInterval[i],
             X[i],
             Y[i]-yInterval[i],
             length = 0.05, angle = 90, code = 3, col = alpha("black", 0.25))
    }
    if(xInterval[i]>0.001){
      arrows(X[i]+xInterval[i],
             Y[i],
             X[i]-xInterval[i],
             Y[i],
             length = 0.05, angle = 90, code = 3, col = alpha("black", 0.25))
    }
  }
}


#___________________________________________________________________________________________________________
# This function constrains CIs to be less than 1 or greater than 0 when that is rational
cropCI <- function(ci) {
  ci <- ifelse(ci > 1, 1, ci)
  ci <- ifelse(ci < 0, 0, ci)
  return(ci)
}


#___________________________________________________________________________________________________________
# These functions draw preset lower and upper quantiles for plotting
qLow <- function(x) {
  q <- quantile(x, probs = 0.10, na.rm = TRUE)
  return(q)
}

qHigh <- function(x) {
  q <- quantile(x, probs = 0.90, na.rm = TRUE)
  return(q)
}


#___________________________________________________________________________________________________________
# This function samples a dataframe and generates transformed output for plotting; originally
# used to explore how many simulations are required for values to stabilize
sampleSims <- function(datFrame, sampleSizeVec, drawVec, aggregate = FALSE){
  sampleDat = NULL
  for(i in seq_along(sampleSizeVec)){
    for(h in seq_along(drawVec)){ #draw each sample size 5 times
      dum <- as.data.frame(sample_n(datFrame, size = sampleSizeVec[i], replace = TRUE))
      dum$nDraw <- drawVec[h]
      dum$nTrials <- sampleSizeVec[i]
      sampleDat <- rbind(sampleDat, dum)
    }
    sampleDat <- rbind(sampleDat, dum)
    sampleDat$nDraw <- factor(sampleDat$nDraw, levels = as.character(drawVec))
    sampleDat$nTrials <- factor(sampleDat$nTrials, levels = as.character(sampleSizeVec))
    if(aggregate == TRUE){
      longDat <- sampleDat %>%
        gather(key = pm, value = value, -c(nDraw,nTrials))
    }
    if(aggregate == FALSE){
      longDat <- sampleDat %>%
        gather(key = cu, value = value, -c(nDraw,nTrials))
    }
  }
  return(longDat)
}


#___________________________________________________________________________________________________________
## This function generates estimates of current PMs using SR parameters, escapement, and catch
# data
# NOTE 1: rec/spwnr/catch PMs based on last 20 yrs of data; SR par PMs based on full TS (due to
# how alpha and beta are estimated)
# NOTE 2: Current SR parameter outputs are based on Ricker model ONLY
genCurrentPMs <- function(srDat, catchDat, parDat, years = 20){

  ##SR data
  srDat$rec <- apply(srDat[, c("rec2", "rec3", "rec4", "rec5", "rec6")], 1, sum)
  srTrim <- srDat %>%
    select(stk, yr, ets, rec) %>%
    mutate(stk = as.factor(stk))
  agTrim <- srDat %>% #calculate aggregate recruits and spawners
    group_by(yr) %>%
    summarise(sumS = sum(ets, na.rm = T),
              sumRecBY = sum(rec, na.rm = T))
  agD <- data.frame(stk = "agg", #reshape to be same dimensions as original SR dat
                    yr = unique(srTrim$yr),
                    ets = agTrim$sumS,
                    rec = agTrim$sumRecBY)
  agDTail <- tail(agD, n = years) #take last n years of data only (ensures PMs are relevant and )
  srPMs <- rbind(srTrim, agDTail) #combine
  srPMs <- srPMs %>% #calculate performance metrics
    group_by(stk) %>%
    summarise(meanS = mean(ets, na.rm = T),
              varS = cv(ets),
              meanRecBY = mean(rec, na.rm = T),
              varRecBY = cv(rec))

  ##catch data
  trimCatch <- catchDat %>% #clean catch data
    select(stk, yr, totCatch) %>%
    mutate(stk = as.factor(stk))
  agCatch <- catchDat %>% #calculate aggregate catch
    group_by(yr) %>%
    summarise(totCatch = sum(totCatch)) %>%
    mutate(stk = "agg")
  agCatch$stk <- as.factor(agCatch$stk)
  agCatch <- tail(agCatch, n = years) #trim to last n years
  temp <- rbind(trimCatch, agCatch[, c(3, 1, 2)])
  catchPMs <- temp %>%
    group_by(stk) %>%
    summarise(meanCatch = mean(totCatch, na.rm = T),
              varCatch = cv(totCatch))

  ##benchmarks based on SR parameters
  parDat <- parDat %>%
    mutate(sMSY = (1 - lambert_W0(exp(1 - alpha)))/beta0, sGen = NA) %>%
    select(stk, alpha, beta0, sigma, sMSY, sGen)
  for (i in seq_along(parDat$stk)) {
    spwnrs <- subset(srDat, stk == i)$ets
    parDat$sGen[i] <- as.numeric(solver.sgen(spwnrs,
                                             theta = c(parDat$alpha[i], parDat$alpha[i]/parDat$beta0[i], parDat$sigma[i]),
                                             parDat$sMSY[i]))
  }
  agPM <- data.frame(stk = "agg", #calculate aggregate benchmarks
                     sMSY = sum(parDat$sMSY),
                     sGen = sum(parDat$sGen))
  parPMs <- rbind(parDat[, c("stk", "sMSY", "sGen")], agPM)
  parPMs$ppnYrsLower <- NA
  parPMs$ppnYrsUpper <- NA
  countLowBM <- rep(0, length.out = nrow(parPMs))
  countUpBM <- rep(0, length.out = nrow(parPMs))
  for (i in seq_along(parPMs$stk)) {
    if (parPMs$stk[i] == "agg") { #pull agg spawner TS from above
      spwnrs <- agD$ets
    } else {
      spwnrs <- subset(srDat, stk == i)$ets
    }
    parPMs$ppnYrsLower[i] <- length(spwnrs[spwnrs > parPMs$sGen[i]]) / length(spwnrs)
    parPMs$ppnYrsUpper[i] <- length(spwnrs[spwnrs > parPMs$sMSY[i]]) / length(spwnrs)
    if (mean(tail(spwnrs, n = 12)) > parPMs$sGen[i]) { #if mean abundance over 3 gens greater than BM counter goes up
      countLowBM[i] <- 1
    }
    if (mean(tail(spwnrs, n = 12)) > parPMs$sMSY[i]) {
      countUpBM[i] <- 1
    }
  }
  parPMs$ppnCULower <- sum(countLowBM) / (length(parPMs$stk) - 1) #subtract one to account for agg level
  parPMs$ppnCUUpper <- sum(countUpBM) / (length(parPMs$stk) - 1) #subtract one to account for agg level

  currentPMs <- Reduce(function(x, y) merge(x, y, by = "stk"), list(srPMs, catchPMs, parPMs))
  currentPMs <- with(currentPMs, currentPMs[order(stk), ])
  names(currentPMs)[c(1:3)] <- c("stkNumber", "meanSpawners", "varSpawners")
  return(currentPMs)
}


#___________________________________________________________________________________________________________
# This function generates lists of scenario (directories) and OM-specific (subdirectories)
# data; passed to genOutputFigs
genOutputList <- function(dirName, subDirName = NULL, selectedCUs = NULL, agg = TRUE,
                          aggTS = FALSE) {
  dirPath <- ifelse(is.null(subDirName), dirName, paste(dirName, subDirName, sep="/"))

  if (agg == TRUE) {
    if (aggTS == TRUE) {
      arrayNames <- list.files(paste(here("outputs/simData"), dirPath, sep="/"), pattern="\\Series.RData$")
      aggList <- list()
      for(i in 1:length(arrayNames)){ #make list of lists!
        aggList[[i]] <- readRDS(paste(here("outputs/simData"), dirPath, arrayNames[i], sep="/"))
      }
      names(aggList) <- arrayNames
      return(aggList)
    } else {
      listNames <- list.files(paste(here("outputs/simData"), dirPath, sep="/"), pattern="*aggDat.csv")
      aggList <- list()
      for(i in 1:length(listNames)){
        aggList[[i]] <- read.csv(paste(here("outputs/simData"), dirPath, listNames[i], sep="/"))
      }
      names(aggList) <- listNames
      return(aggList)
    }
  }

  if (agg == FALSE) {
    dfNames <- list.files(paste(here("outputs/simData"), dirPath, sep="/"), pattern="\\cuDat.RData$")
    cuList <- list()
    newNames <- NULL
    for(i in 1:length(dfNames)){ #make list of lists!
      cuList[[i]] <- readRDS(paste(here("outputs/simData"), dirPath, dfNames[i], sep="/"))
      newName <- unlist(strsplit(dfNames[i], "_cuDat"))[1] #identify and assign truncated name to CU-specific list
      # newNames <- c(newNames, paste("fixed", newName, sep = ""))
      newNames <- c(newNames, newName)
    }
    names(cuList) <- newNames

    if (is.null(selectedCUs) == FALSE) { #subset CU list based on input vector
      cuNumbers <- which(cuList[[1]][["stkName"]] %in% selectedCUs)
      cuList <- lapply(cuList, function(lst) {
        tempList <- vector("list", length = length(lst))
        tempList[1:4] <- lst[c("opMod", "keyVar", "plotOrder", "hcr")]
        for (i in 5:length(lst)) {
          if (is.matrix(lst[[i]]) == TRUE){
            temp <- lst[[i]][, cuNumbers]
          }
          if (is.vector(lst[[i]]) == TRUE){
            temp <- lst[[i]][cuNumbers]
          }
          tempList[[i]] <- temp
        }
        names(tempList) <- names(lst)
        return(tempList)
      })
    }
   return(cuList)
  }
}


#___________________________________________________________________________________________________________
# This function builds dataframes around key variables that change across scenarios;
# extension of genOutputList
# Each combination of directory, subdirectory, and key variable levels should represent a unique scenario
# E.g. Different keyvariables (proportion allocated to mixed fisheries) nested within OM
# (productivity regime) nested within higher level MP or additional OM (e.g. fixed or TAM)
buildDataCU <- function(dirNames, cuVars, keyVarName, selectedCUs = NULL) {
  cuData = NULL #construct CU dataframe
  for (i in seq_along(dirNames)) {
    subDirs <- list.dirs(path = paste(here("outputs/simData"), dirNames[i], sep = "/"), full.names = FALSE,
                         recursive = FALSE) #alternatively ID OMs based on prespecified directory

    for (j in seq_along(subDirs)) {
      if (is.null(selectedCUs == TRUE)) {
        cuList <- genOutputList(dirNames[i], subDirs[j], agg = FALSE)
      } else {
        cuList <- genOutputList(dirNames[i], subDirs[j], selectedCUs = selectedCUs, agg = FALSE)
      }

      nCU <- length(cuList[[1]]$stkName)
      keyVarValue <- rep(sapply(cuList, function(x) unique(x$keyVar)), each  = nCU)
      plotOrder <- rep(sapply(cuList, function(x) unique(x$plotOrder)), each = nCU)
      cuName <- as.vector(sapply(cuList, function(x) x$stkName))
      muName <- as.vector(sapply(cuList, function(x) x$manUnit))
      singleScenDat = NULL
      for (k in seq_along(cuVars)) {
        dum <- data.frame(keyVar = keyVarValue,
                          mp = sapply(cuList, function(x) x$hcr),
                          om = sapply(cuList, function(x) x$opMod),
                          plotOrder = as.factor(plotOrder),
                          cuName = as.factor(cuName),
                          muName = as.factor(muName)),
                          var = rep(cuVars[k], length.out = length(cuList)),
                          avg = as.vector(sapply(cuList, function(x)
                            apply(x[[cuVars[k]]], 2, median))),
                          lowQ = as.vector(sapply(cuList, function(x)
                            apply(x[[cuVars[k]]], 2, qLow))),
                          highQ = as.vector(sapply(cuList, function(x)
                            apply(x[[cuVars[k]]], 2, qHigh))),
                          row.names = NULL
        )
        singleScenDat <- rbind(singleScenDat, dum, row.names = NULL)
      }
      names(singleScenDat)[1] <- keyVarName
      cuData <- rbind(cuData, singleScenDat)
    }
  }
  return(cuData)
}

#___________________________________________________________________________________________________________
# This function modifies S. Anderson's theme_sleek w/ gridlines that help w/ latticed plots
theme_sleek_grid <- function(base_size = 11, base_family = "") {
  half_line <- base_size/2
  theme_light(base_size = 11, base_family = "") +
    theme(
      panel.grid.major = element_line(colour = "grey30", size = 0.1),
      panel.grid.minor = element_blank(),
      axis.ticks.length = unit(half_line / 2.2, "pt"),
      strip.background = element_rect(fill = NA, colour = NA),
      strip.text.x = element_text(colour = "grey30"),
      strip.text.y = element_text(colour = "grey30"),
      axis.text = element_text(colour = "grey30"),
      axis.title = element_text(colour = "grey30"),
      legend.title = element_text(colour = "grey30", size = rel(0.9)),
      panel.border = element_rect(fill = NA, colour = "grey70", size = 1),
      legend.key.size = unit(0.9, "lines"),
      legend.text = element_text(size = rel(0.7), colour = "grey30"),
      legend.key = element_rect(colour = NA, fill = NA),
      legend.background = element_rect(colour = NA, fill = NA),
      plot.title = element_text(colour = "grey30", size = rel(1)),
      plot.subtitle = element_text(colour = "grey30", size = rel(.85))
    )
}


#___________________________________________________________________________________________________________
# This function is a copy of S. Anderson's now that ggsidekick is not supported; adds argument
# for top, bottom, middle for multipanel functionality
theme_sleekX <- function(base_size = 11, base_family = "", position = "standard") {
  half_line <- base_size/2
  q <- theme_light(base_size = 11, base_family = "") +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      axis.ticks.length = unit(half_line / 2.2, "pt"),
      strip.background = element_rect(fill = NA, colour = NA),
      strip.text.x = element_text(colour = "grey30"),
      strip.text.y = element_text(colour = "grey30"),
      axis.text = element_text(colour = "grey30"),
      axis.title = element_text(colour = "grey30"),
      legend.title = element_text(colour = "grey30", size = rel(1.1)),
      panel.border = element_rect(fill = NA, colour = "grey70", size = 1),
      legend.key.size = unit(1, "lines"),
      legend.text = element_text(size = rel(1), colour = "grey30"),
      legend.key = element_rect(colour = NA, fill = NA),
      legend.background = element_rect(colour = NA, fill = NA),
      plot.title = element_text(colour = "grey30", size = rel(1)),
      plot.subtitle = element_text(colour = "grey30", size = rel(.85))
    )
  if (position == "bottom") {
    q <- q + theme(strip.background = element_blank(),
                   strip.text.x = element_blank(),
                   strip.text.y = element_blank(),
                  axis.text.y = element_text(size = 0.85 * axisSize),
                  axis.text.x = element_text(size = 0.85 * axisSize),
                  axis.title = element_text(size = axisSize)
    )
  }
  if (position == "top") {
    q <- q + theme(strip.text = element_text(size = axisSize),
                  axis.text.y = element_text(size = 0.85 * axisSize),
                  axis.text.x = element_blank(),
                  axis.title.y = element_text(size = axisSize),
                  axis.title.x = element_blank()
    )
  }
  if (position == "topWithX") {
    q <- q + theme(strip.text = element_text(size = axisSize),
                   axis.text.y = element_text(size = 0.85 * axisSize),
                   axis.text.x = element_text(size = 0.85 * axisSize),
                   axis.title.y = element_text(size = axisSize),
                   axis.title.x = element_blank()
    )
  }
  if (position == "mid") {
    q <- q + theme(strip.background = element_blank(),
                   strip.text.x = element_blank(),
                   strip.text.y = element_blank(),
                  axis.text.y = element_text(size = 0.85 * axisSize),
                  axis.text.x = element_blank(),
                  axis.title.y = element_text(size = axisSize),
                  axis.title.x = element_blank()
    )
  }
  return(q)
}


#___________________________________________________________________________________________________________
# These functions generate cu-specific and agg figures from specified folders (representing
# a set of scenarios run simultaneously) and subfolders (representing different operating models)
# CU-specific data is read within the function because passing lists of lists of lists tends to lead to errors
# Aggregate data is read within the function because there's little sense in pulling out just one

## Generate CU-specific figs
genCuOutputFigs <- function(dirName, subDirName, selectedCUs = NULL) {
  ## Import data
  if (is.null(selectedCUs == TRUE)) {
    cuList <- genOutputList(dirName, subDirName, agg = FALSE)
  } else {
    cuList <- genOutputList(dirName, subDirName, selectedCUs = selectedCUs, agg = FALSE)
  }

  ifelse(!dir.exists(paste(here("outputs/summaryFigs"), dirName, sep = "/")),
         dir.create(paste(here("outputs/summaryFigs"), dirName, sep = "/")),
         FALSE) #create dir if it doesn't already exist
  ifelse(!dir.exists(paste(here("outputs/summaryFigs"), dirName, subDirName, sep = "/")),
         dir.create(paste(here("outputs/summaryFigs"), dirName, subDirName, sep = "/")),
         FALSE) #create subdir if it doesn't already exist

  ## CU-specific plots
  pdf(file = paste(here("outputs/summaryFigs", dirName, subDirName, "cuCatchTradeoffUncert.pdf"),
                   sep = "/"), height = 6, width = 7)
  plotCUCatchTradeOffs(cuList = cuList, nCU = length(cuList[[1]]$stkName),
                       catchVars = c("medCatch"),
                       consVars = c("medSpawners", "ppnYrsUpper",
                                    "ppnYrsLower"),
                       wrap = "CU",
                       showUncertainty = TRUE,
                       axisSize = 15, dotSize = 4.5, lineSize = 0.8, legendSize = 14)
  dev.off()

  pdf(file = paste(here("outputs/summaryFigs", dirName, subDirName, "cuCatchTradeoff.pdf"),
                   sep = "/"), height = 6, width = 7)
  plotCUCatchTradeOffs(cuList = cuList, nCU = length(cuList[[1]]$stkName),
                       catchVars = c("medCatch"),
                       consVars = c("medSpawners", "ppnYrsUpper",
                                    "ppnYrsLower"),
                       wrap = "CU",
                       showUncertainty = FALSE,
                       axisSize = 15, dotSize = 4.5, lineSize = 0.8, legendSize = 14)
  dev.off()

  pdf(file = paste(here("outputs/summaryFigs", dirName, subDirName, "cuPpns.pdf"),
                   sep = "/"), height = 6, width = 7)
  ppnDotPlotMP(datList = cuList,
               vars = c("ppnYrsUpper", "ppnYrsLower",
                        #"ppnYrsEstUpper", "ppnYrsEstLower",
                        "ppnYrsCOS", "ppnYrsWSP"
                        # , "ppnYrsMixCatch", "ppnYrsSingCatch"
               ),
               agg = FALSE, axisSize = 15, dotSize = 4.5, lineSize = 0.8, legendSize = 14)
  dev.off()
}


## Generate aggregate ouput figures
genAgOutputFigs <- function(dirName, subDirName){
  ## Import data
  aggList <- genOutputList(dirName, subDirName, agg = TRUE)
  aggTS <- genOutputList(dirName, subDirName, agg = TRUE, aggTS = TRUE)

  ifelse(!dir.exists(paste(here("outputs/summaryFigs"), dirName, sep="/")),
         dir.create(paste(here("outputs/summaryFigs"), dirName, sep="/")),
         FALSE) #create dir if it doesn't already exist
  ifelse(!dir.exists(paste(here("outputs/summaryFigs"), dirName, subDirName, sep="/")),
         dir.create(paste(here("outputs/summaryFigs"), dirName, subDirName, sep="/")),
         FALSE) #create dir if it doesn't already exist

  ## Agg plots
  pdf(file = paste(here("outputs/summaryFigs", dirName, subDirName, "agCatchTradeoffUncert.pdf"),
                   sep = "/"), height = 6, width = 7)
  plotAgCatchTradeOffs(aggList = aggList,
                       catchVars = c("medCatch"),
                       consVars = c("medSpawners", "ppnCULower", "ppnCUExtant"),
                       showUncertainty = TRUE,
                       axisSize = 15, dotSize = 4.5, lineSize = 0.8, legendSize = 14)
  dev.off()

  pdf(file = paste(here("outputs/summaryFigs", dirName, subDirName, "aggPpns.pdf"),
                   sep = "/"), height = 6, width = 7)
  ppnDotPlotMP(datList = aggList,
               vars = c("ppnYrsCUsUpper", "ppnYrsCUsLower", "ppnCUUpper", "ppnCULower",
                        "ppnYrsAllOpen", "ppnCUExtinct"
               ),
               agg = TRUE,
               axisSize = 15, dotSize = 4.5, lineSize = 0.8, legendSize = 14)
  dev.off()

  pdf(file = paste(here("outputs/summaryFigs", dirName, subDirName, "aggTS_Uncert.pdf"),
                   sep = "/"), height = 6, width = 7)
  plotAggTS(datList = aggTS,
            vars = c("Ag Spawners", "Ag Recruits RY", "Ag Catch"),
            uncertainty = TRUE, showTrials = TRUE,
            axisSize = 15, lineSize = 0.8, legendSize = 14)
  dev.off()

  pdf(file = paste(here("outputs/summaryFigs", dirName, subDirName, "aggTS.pdf"),
                   sep = "/"), height = 6, width = 7)
  plotAggTS(datList = aggTS,
            vars = c("Ag Spawners", "Ag Recruits RY", "Ag Catch"),
            uncertainty = FALSE, showTrials = FALSE,
            axisSize = 15, lineSize = 0.8, legendSize = 14)
  dev.off()
}


#___________________________________________________________________________________________________________
# This function calculate synchrony metrics using arrays of raw data produced by recoverySim
calcSynchMetrics <- function(synchList, windowSize = 10, synch = TRUE, compCV = TRUE, agCV = TRUE,
                             corr = FALSE) {
  recBY <- synchList$recBY
  logRS <- synchList$logRS
  nYears <- dim(recBY)[1]
  nTrials <- dim(recBY)[3]

  synchRecBY <- matrix(NA, nrow = nYears, ncol = nTrials)
  synchLogRS <- matrix(NA, nrow = nYears, ncol = nTrials)
  compCVRecBY <- matrix(NA, nrow = nYears, ncol = nTrials)
  compCVLogRS <- matrix(NA, nrow = nYears, ncol = nTrials)
  agCVRecBY <- matrix(NA, nrow = nYears, ncol = nTrials)
  agCVLogRS <- matrix(NA, nrow = nYears, ncol = nTrials)

  for (n in 1:nTrials) {
    if (synch == TRUE) {
      synchRecBY[ , n] <- rollapplyr(recBY[ , , n], width = windowSize, function(x) community.sync(x)$obs,
                                     fill = NA, by.column = FALSE)
      synchLogRS[ , n] <- rollapplyr(logRS[ , , n], width = windowSize, function(x) community.sync(x)$obs,
                                     fill = NA, by.column = FALSE)
    }
    if (compCV == TRUE) {
      compCVRecBY[ , n] <- rollapplyr(recBY[ , , n], width = windowSize, function(x) wtdCV(x), fill = NA,
                                      by.column = FALSE)
      compCVLogRS[ , n] <- rollapplyr(logRS[ , , n], width = windowSize, function(x) wtdCV(x), fill = NA,
                                      by.column = FALSE)
    }
    if (agCV == TRUE) {
      agCVRecBY[ , n] <- rollapplyr(recBY[ , , n], width = windowSize, function(x) cvAgg(x), fill = NA,
                                    by.column = FALSE)
      agCVLogRS[ , n] <- rollapplyr(logRS[ , , n], width = windowSize, function(x) cvAgg(x), fill = NA,
                                    by.column = FALSE)
    }
  }
  outputList <- list(synchRecBY, synchLogRS, compCVRecBY, compCVLogRS, agCVRecBY,
                     agCVLogRS)
  names(outputList) <- c("synchRecBY", "synchLogRS", "compCVRecBY", "compCVLogRS", "agCVRecBY",
                         "agCVLogRS")
  return(outputList)
}


#_______________________________________________________________________________________
#### PLOTTING FUNCTIONS ####
#_______________________________________________________________________________________


#___________________________________________________________________________________________________________
# New version of CU-specific trade off plot (depredated code pasted below); uses data frame generated
# using buildDataCU function
plotCUTradeoff <- function(cuDat, consVar = "medSpawners", catchVar = "medCatch",
                           wrap = "mu", multipanel = "om",
                           showUncertainty = FALSE,
                           legendLab = NULL, xLab = NULL, yLab = NULL,
                           axisSize = 14, dotSize = 4, lineSize = 1.25,
                           legendSize = 14) {
  if (is.null(xLab) | is.null(yLab)) {
    warning("Suggest adding axis labels to interpret")
  }
  #save index variables
  nCU <- length(unique(cuDat$cuName))
  colPal <- viridis(nCU, begin = 0, end = 1)
  #identify whether second dimension of plots should be by om or MP
  #(first dimension is by keyvariable, faceting is by CU/MU)
  if (multipanel == "om") {
    panels <- unique(cuDat$om)
  }
  if (multipanel == "mp") {
    panels <- unique(cuDat$mp)
  }

  # Plot
  plotList <- lapply(seq_along(panels), function(h) { #iterate across catch variables
    if (multipanel == "om") {
      dum <- cuDat %>%
        filter(om == panels[h],
               var == catchVar | var == consVar)
    }
    if (multipanel == "mp") {
      dum <- cuDat %>%
        filter(mp == panels[h],
               var == catchVar | var == consVar)
    }
    dum$var <- plyr::mapvalues(dum$var, from = c(consVar, catchVar), #change factor names to make plotting universal
                               to = c("consVar", "catchVar"))
    #necessary to spread for tradeoff plots; NOTE: if errors, check indexing correct)
    wideDum <- dum %>%
      gather(temp, value, 8:10) %>%
      unite(temp1, var, temp, sep = "_") %>%
      spread(temp1, value) %>%
      dplyr::rename(keyVar = 1) %>%
      mutate(keyVar = as.factor(keyVar))

    p <- ggplot(wideDum, aes(x = catchVar_avg, y = consVar_avg, shape = mp,
                             alpha = keyVar, fill = cuName)) +
      geom_point(size = dotSize) +
      theme_sleekX() +
      theme(strip.text = element_text(size = axisSize),
            axis.text = element_text(size = 0.9 * axisSize),
            axis.title = element_text(size = axisSize),
            legend.text = element_text(size = 0.9 * legendSize),
            legend.title = element_text(size = legendSize)) +
      xlab(xLab) +
      ylab(yLab) +
      scale_shape_manual(values = c(21, 25), name = "Control Rule") +
      scale_alpha_discrete(range = c(0.3, 1), name = legendLab)  +
      scale_fill_manual(values = colPal, name = "CU")
    if (length(unique(wideDum$mp)) < 2) {
      p <- p +
        guides(shape = "none")
    } else {
      p <- p +
        guides(shape = guide_legend(override.aes = list(fill = "black")))
    }
    if (wrap == "mu") {
      p <- p +
        facet_wrap(~muName, scales = "free") +
        guides(fill = guide_legend(override.aes = list(shape = 21, colour = "black",
                                                       fill = colPal)))
    }
    if (wrap == "cu") {
      p <- p +
        facet_wrap(~cuName, scales = "free") +
        guides(fill = FALSE)
    }
    if (showUncertainty == FALSE) {
      return(p)
    }
    if (showUncertainty==TRUE) {
      q <- p +
        geom_errorbar(aes(ymin = consVar_lowQ, ymax = consVar_highQ),
                      alpha = 0.3, width = 0, size = lineSize) +
        geom_errorbarh(aes(xmin = catchVar_lowQ, xmax = catchVar_highQ),
                       alpha = 0.3, height = 0, size = lineSize)
      return(q)
    }
  }) #end panel lapply subset
  names(plotList) <- sapply(panels, function(x) paste(x, "Plot", sep = ""))
  return(plotList)
}




#___________________________________________________________________________________________________________


# This function generates plotting data from aggregate then generates:
# Dot plots comparing aggregate total catch to a suite of aggregate conservation performance metrics
plotAgCatchTradeOffs <- function(aggList, catchVars, consVars, showUncertainty = FALSE,
                                 axisSize = 14, dotSize = 3, lineSize = 0.8, legendSize = 14) {
  # make data frame containing data to plot
  plotDat <- NULL
  vars = c(catchVars, consVars)
  hcr <- sapply(aggList, function(x) unique(x$hcr))
  keyVar <- sapply(aggList, function(x) unique(x$keyVar))
  # er <- sapply(aggList, function(x) mean(x$targetER))
  lowCatchVars <- paste("low", catchVars, sep = "_") #index for looping
  lowConsVars <- paste("low", consVars, sep = "_") #index for looping
  highCatchVars <- paste("high", catchVars, sep = "_") #index for looping
  highConsVars <- paste("high", consVars, sep = "_") #index for looping
  for(j in seq_along(vars)){
    dum <- data.frame(var = rep(vars[j], length.out = length(aggList)),
                      hcr = hcr,
                      keyVar = as.factor(keyVar),
                      # er = er,
                      avg = sapply(aggList, function(x) median(x[,vars[j]])),
                      lowQ = sapply(aggList, function(x) qLow(x[,vars[j]])),
                      highQ = sapply(aggList, function(x) qHigh(x[,vars[j]]))
    )
    plotDat <- rbind(plotDat, dum)
  }
  rownames(plotDat) <- c()

  plotDat$key <- paste(hcr, keyVar, sep="_")
  plotAvg <- plotDat %>% select(-lowQ, -highQ) %>% spread(var, avg)
  plotLow <- plotDat %>% select(key, var, lowQ) %>% spread(var, lowQ)
  names(plotLow)[2:ncol(plotLow)] <- paste("low", names(plotLow)[2:ncol(plotLow)], sep="_")
  plotHigh <- plotDat %>% select(key, var, highQ) %>% spread(var, highQ)
  names(plotHigh)[2:ncol(plotHigh)] <- paste("high", names(plotHigh)[2:ncol(plotHigh)], sep="_")
  temp <- Reduce(function(x, y) merge(x, y, by = "key"), list(plotAvg, plotLow, plotHigh))
  plotD <- subset(temp, select = -c(key))

  # Plot
  for (h in seq_along(catchVars)) { #iterate across catch variables
    for (i in seq_along(consVars)) { #iterate across catch variables
      dum <- plotD %>%
        select(hcr, keyVar, catchVar = catchVars[h], consVar = consVars[i],
               lowCatch = lowCatchVars[h], lowCons = lowConsVars[i],
               highCatch = highCatchVars[h], highCons = highConsVars[i])
      p <- ggplot(dum, aes(x = catchVar, y = consVar, shape = hcr, alpha = keyVar)) +
        geom_point(size = dotSize, fill = "black") +
        theme_sleek() +
        theme(axis.text = element_text(size = 0.9 * axisSize),
              axis.title = element_text(size = axisSize),
              legend.text = element_text(size = 0.9 * legendSize),
              legend.title = element_text(size = legendSize)) +
        xlab(catchVars[h]) +
        ylab(consVars[i]) +
        scale_shape_manual(values = c(21, 25), name = "Control Rule") +
        scale_alpha_discrete(range = c(0.3, 1), name = "Man. Proc.")
      if (length(unique(dum$hcr)) == 1) {
        p <- p +
          guides(shape = "none")
      } else {
        p <- p +
          guides(shape = guide_legend(override.aes = list(fill = "black")))
      }
      if (showUncertainty == FALSE) {
        print(p)
      }
      if (showUncertainty == TRUE) {
        q <- p +
          geom_errorbar(aes(ymin = lowCons, ymax = highCons),
                        alpha = 0.3, width = 0, size = lineSize) +
          geom_errorbarh(aes(xmin = lowCatch, xmax = highCatch),
                         alpha = 0.3, height = 0, size = lineSize)
        print(q)
      }
    } #end conservation variable subset
  } #end catch variable subset
}


#___________________________________________________________________________________________________________
# This function generates dotplots of proportional performance metrics by management procedure
ppnDotPlotMP <- function(datList, vars, agg = TRUE, axisSize = 14,
                         dotSize = 3.5, lineSize = 0.8, legendSize = 14) {
  if (agg == TRUE) {
    hcr <- sapply(datList, function(x) unique(x$hcr))
    keyVar <- sapply(datList, function(x) unique(x$keyVar))
    # er <- sapply(datList, function(x) mean(x$targetER))
    plotDat = NULL
    for (i in seq_along(vars)) {
      dum <- data.frame(var = rep(vars[i], length.out = length(datList)),
                        hcr = hcr,
                        keyVar = keyVar,
                        # er = er,
                        avg = sapply(datList, function(x) median(x[, vars[i]])),
                        lowQ = sapply(datList, function(x) qLow(x[, vars[i]])),
                        highQ = sapply(datList, function(x) qHigh(x[, vars[i]]))
      )
      dum <- dum[order(dum$hcr, dum$keyVar), ]
      plotDat <- rbind(plotDat, dum)
    }
    plotDat$sym <- ifelse(plotDat$hcr == "fixedER", 21, 25)
    rownames(plotDat) <- c()

    p <- ggplot(plotDat, aes(factor(keyVar), y = avg, ymin = lowQ, ymax = highQ,
                           shape = as.factor(sym), fill = "black")) +
      labs(x = "Harvest Control Rule", y = "Proportion of Years/CUs Above Benchmark") +
      geom_pointrange(fatten = dotSize, size = lineSize) +
      # theme_sleek_grid() +
      theme_sleek() +
      theme(strip.text = element_text(size = axisSize),
            axis.text = element_text(size = 0.85 * axisSize),
            axis.title = element_text(size = axisSize),
            legend.position = "none") +
      facet_wrap(~var, scales = "free_y")
    print(p)
  }

  if (agg == FALSE) { #cu-specific plots
    nCU <- length(datList[[1]]$stkName)
    hcr <- rep(as.vector(sapply(datList, function(x) x$hcr)), each = nCU)
    cu <- as.vector(sapply(datList, function(x) x$stkName))
    keyVar <- rep(as.vector(sapply(datList, function(x) x$keyVar)), each = nCU)
    # er <- as.vector(sapply(datList, function(x) apply(x$targetER, 2, mean)))
    for(i in seq_along(vars)){
      dum <- data.frame(hcr = hcr,
                        cu = cu,
                        var = rep(vars[i], length.out = nCU * length(datList)),
                        keyVar = keyVar,
                        # er = er,
                        avg = as.vector(sapply(datList, function(x) {
                          apply(data.frame(x[names(x) %in% vars[i]]), 2, function(z) {
                            median(z, na.rm = T)
                            })
                          })),
                        lowQ = as.vector(sapply(datList, function(x) {
                          apply(data.frame(x[names(x) %in% vars[i]]), 2, function(z) {
                            qLow(z)
                          })
                        })),
                        highQ = as.vector(sapply(datList, function(x) {
                          apply(data.frame(x[names(x) %in% vars[i]]), 2, function(z) {
                            qHigh(z)
                          })
                        }))
      )
      dum <- dum[order(dum$var, dum$cu, dum$keyVar),]
      row.names(dum) <- c()
      dum$sym <- ifelse(dum$hcr == "fixedER", 21, 25)
      p <- ggplot(dum, aes(factor(keyVar), y = avg, ymin = lowQ, ymax = highQ,
                         shape = as.factor(sym), fill = "black")) +
        labs(x = "Harvest Control Rule", y = vars[i]) +
        geom_pointrange(fatten = dotSize, size = lineSize) +
        theme_sleek() +
        theme(strip.text = element_text(size = axisSize),
              axis.text = element_text(size = 0.85 * axisSize),
              axis.title = element_text(size = axisSize),
              legend.text = element_text(size = 0.95 * legendSize),
              legend.title = element_text(size = legendSize)) +
        theme(legend.position = "none") +
        facet_wrap(~cu, scales = "free_y")
      print(p)
    } #end for i in seq_along(vars)
  } #end if agg==FALSE
}


#___________________________________________________________________________________________________________
# This function generates dotplots of proportional performance metrics by operating model
ppnDotPlotOM <- function(datList, vars, yAxisLab = NULL, agg = TRUE, axisSize = 15, dotSize = 3.5, lineSize = 0.8,
                         legendSize = 14, figName = NULL) {
  if (agg == TRUE) {
    # om <- sapply(datList, function(x) unique(x$opMod))
    keyVar <- sapply(datList, function(x) unique(x$keyVar))
    plotOrder <- sapply(datList, function(x) unique(x$plotOrder))
    plotDat = NULL
    for (i in seq_along(vars)) {
      dum <- data.frame(var = rep(vars[i], length.out = length(datList)),
                        # om = abbreviate(substr(as.character(om), 1, 6), minlength = 4),
                        keyVar = as.factor(keyVar),
                        plotOrder = plotOrder,
                        avg = sapply(datList, function(x) median(x[,vars[i]])),
                        lowQ = sapply(datList, function(x) qLow(x[,vars[i]])),
                        highQ = sapply(datList, function(x) qHigh(x[,vars[i]]))
      )
      plotDat <- rbind(plotDat, dum)
    }
    rownames(plotDat) <- c()
    # plotDat$om <- factor(plotDat$om, levels = unique(plotDat$om[order(plotDat$var, plotDat$avg, plotDat$om)]),
    # plotDat$om <- factor(plotDat$om, levels = unique(plotDat$om[order(plotDat$var, plotDat$plotOrder)]),
    #                      ordered = TRUE) #arrange data frame so that factor levels in ascending order
    yAxisLab <- ifelse(is.null(yAxisLab), "", yAxisLab)
    p <- ggplot(plotDat, aes(keyVar, y = avg, ymin = lowQ, ymax = highQ)) +
      labs(x = "Operating Model", y = yAxisLab, title = figName) +
      geom_pointrange(fatten = dotSize, size = lineSize) +
      theme_sleek() +
      theme(strip.text = element_text(size = axisSize),
            axis.text = element_text(size = 0.85 * axisSize),
            axis.title = element_text(size = axisSize),
            axis.text.x = element_text(angle = 90, hjust = 1)) +
      facet_wrap(~var)
    print(p)
  }

  if (agg == FALSE) { #cu-specific plots
    nCU <- length(datList[[1]]$stkName)
    # om <- rep(as.vector(sapply(datList, function(x) unique(x$opMod))), each = nCU)
    keyVar <- rep(as.vector(sapply(datList, function(x) unique(x$keyVar))), each = nCU)
    plotOrder <- rep(as.vector(sapply(datList, function(x) unique(x$plotOrder))), each = nCU)
    cu <- as.vector(sapply(datList, function(x) x$stkName))
    for(i in seq_along(vars)){
      dum <- data.frame(keyVar = as.factor(keyVar),
                        # om = abbreviate(substr(om, 1, 6), minlength = 4),
                        plotOrder = plotOrder,
                        cu = cu,
                        var = rep(vars[i], length.out = nCU * length(datList)),
                        avg = as.vector(sapply(datList, function(x) {
                          apply(data.frame(x[names(x) %in% vars[i]]), 2, median)
                          })),
                        lowQ = as.vector(sapply(datList, function(x) {
                          apply(data.frame(x[names(x) %in% vars[i]]), 2, qLow)
                          })),
                        highQ = as.vector(sapply(datList, function(x) {
                          apply(data.frame(x[names(x) %in% vars[i]]), 2, qHigh)
                        }))
      )
      # dum$om <- factor(dum$om, levels = unique(dum$om[order(dum$plotOrder)]),
      #                  ordered = TRUE)
      p <- ggplot(dum, aes(x = keyVar, y = avg, ymin = lowQ, ymax = highQ)) +
        labs(x = "Operating Model", y = vars[i], title = figName) +
        geom_pointrange(fatten = dotSize, size = lineSize) +
        theme_sleek() +
        theme(strip.text = element_text(size = axisSize),
              axis.text = element_text(size = 0.85 * axisSize),
              axis.title = element_text(size = axisSize),
              axis.text.x = element_text(angle = 90, hjust = 1)) +
        facet_wrap(~cu)
      print(p)
    }
  }
}


#___________________________________________________________________________________________________________
# This function generates grouped dotplots so that multiple scenarios with equivalent
# OMs can be compared simultaneously
# dirNames identified different scenarios to be imported, vars is a vector of PMs to plot
# xVar/groupVar are the factor variables structure plot,
# facetNames replaces the default PM names MAKE SURE THEY ARE IN THE SAME ORDER AS VARS ARGUMENT
groupedDotPlot <- function(dirNames, vars, facetNames = NULL,
                           yAxisLab = NULL, yScales = NULL, axisSize = 15, dotSize = 3.5, lineSize = 0.8,
                           legendSize = 14, figName = NULL) {
  plotDat = NULL
  for(h in seq_along(dirNames)) {
    agList <- genOutputList(dirNames[h], agg = TRUE)
    keyVar <- sapply(agList, function(x) unique(x$keyVar))
    plotOrder <- sapply(agList, function(x) unique(x$plotOrder))
    singleScen = NULL
    for (i in seq_along(vars)) {
      dum <- data.frame(scen = rep(dirNames[h], length.out = length(agList)),
                        var = rep(vars[i], length.out = length(agList)),
                        keyVar = as.factor(keyVar),
                        cat = as.factor(plotOrder),
                        avg = sapply(agList, function(x) median(x[,vars[i]])),
                        lowQ = sapply(agList, function(x) qLow(x[,vars[i]])),
                        highQ = sapply(agList, function(x) qHigh(x[,vars[i]]))
      )
      singleScen <- rbind(singleScen, dum)
    }
    rownames(singleScen) <- c()
    plotDat <- rbind(plotDat, singleScen) #merge multiple scenarios into one dataframe
  }
  if (is.null(facetNames) == FALSE) {
    levels(plotDat$var) <- facetNames
  }
  levels(plotDat$cat) <- c("low", "med", "high")
  levels(plotDat$scen) <- c("synch", "CV", "synch\n+ CV")
  colPal <- viridis(length(levels(plotDat$cat)), begin = 0, end = 1)
  names(colPal) <- levels(plotDat$cat)
  p <- ggplot(plotDat, aes(x = scen, y = avg, ymin = lowQ, ymax = highQ, color = cat)) +
    labs(x = "Operating Model", y = yAxisLab, color = "Sim.\nParameter\nValue") +
    geom_pointrange(fatten = dotSize, size = lineSize, position = position_dodge(width = 0.5)) +
    theme_sleek() +
    scale_colour_manual(name = "Operating Model", values = colPal) +
    theme(strip.text = element_text(size = axisSize),
          axis.text = element_text(size = 0.85 * axisSize),
          axis.title = element_text(size = axisSize),
          legend.text = element_text(size = 0.85 * axisSize),
          legend.title = element_text(size = 0.95 * axisSize)) +
    facet_wrap(~var, scales = yScales)
  return(p)
}


#___________________________________________________________________________________________________________
# This function generates plotting data from aggregate and plots continuous trade-off plot
# (e.g. C Walters Skeena) contrasting changes in escapement, catch and extinction risk
plotContTradeOffs <- function(aggList, catchVars, consVars) {
  # make data frame containing data to plot
  plotDat <- NULL
  vars = c(catchVars, consVars)
  index = c(rep("catch", length.out = length(catchVars)), rep("cons", length.out = length(consVars)))
  hcr <- sapply(aggList, function(x) unique(x$hcr))
  er <- sapply(aggList, function(x) mean(x$targetER))
  for(i in seq_along(vars)){
    dum <- data.frame(var = rep(vars[i], length.out = length(aggList)),
                      type = rep(index[i], length.out = length(aggList)),
                      hcr = hcr,
                      er = er,
                      avg = sapply(aggList, function(x) mean(x[, vars[i]])),
                      lowQ = sapply(aggList, function(x) qLow(x[, vars[i]])),
                      highQ = sapply(aggList, function(x) qHigh(x[, vars[i]]))
    )
    plotDat <- rbind(plotDat, dum)
  }
  plotDat$colAlpha <- rep(seq(from = 0.1, to = 1, length = length(aggList)),
                          length.out = nrow(plotDat)) #vector to fade based on ER
  plotDat$sym <- ifelse(plotDat$hcr == "fixedER", 21, 25)
  plotDat$er <- ifelse(plotDat$hcr == "fixedER", plotDat$er, "TAM")
  rownames(plotDat) <- c()

  #colors for plot
  escCol <- "#984ea3"
  bmCol <- "#4daf4a"
  catchCol <- "#377eb8"
  extCol <- "#e41a1c"

  # continuous plot without TAM
  # mat<-matrix(1, 100, 100)
  # mat[1:100, 80:100] <- 2
  par(mfrow = c(1, 1), mar = c(3.75, 4, 1.25, 4.5), oma = c(0, 0, 0, 0),
      cex.lab = 1)
  # layout(mat)

  tamDat <- plotDat[plotDat$hcr == "TAM", ]
  plotDat <- plotDat[!plotDat$hcr == "TAM", ] #plot isn't compatible w/ TAM so remove
  plotDat <- plotDat[order(plotDat[,"var"], plotDat[,"er"]), ] #make sure ordered sequentially by variable THEN key
  plotS <- plotDat[plotDat$var == "meanSpawners", ]
  plotC <- plotDat[plotDat$var == "meanCatch", ]
  plotExt <- plotDat[plotDat$var == "ppnCUExtinct", ]
  plotUpperBM <- plotDat[plotDat$var == "ppnCULower", ]
  plotER <- as.numeric(unique(plotDat$er))
  # tamDat$refX <- max(plotER) * 1.1 # reference index to plot values to right of lines

  plot(1, type="n", axes = FALSE, xlim = c(min(plotER), max(plotER)),
       ylim = c(0, max(plotS$avg, plotC$avg, plotExt$avg)),
       xlab = "", ylab = "")
  lines(plotS$avg ~ plotER, xaxt = "n", yaxt = "n", type = "l", lwd = 1.25, col = escCol)
  lines(plotC$avg ~ plotER, xaxt = "n", yaxt = "n", type = "l", lwd = 1.25, col = catchCol)
  shade(rbind(plotS$lowQ, plotS$highQ), plotER, col = alpha(escCol, 0.3))
  shade(rbind(plotC$lowQ, plotC$highQ), plotER, col = alpha(catchCol, 0.3))
  axis(1, tick = T, at = c(seq(from = -0.2, to = 1, by = 0.2)), mgp = c(3, 0.5, 0))
  mtext(side = 1, line = 2.25, 'Exploitation Rate', cex = 1.2)
  if(mean(plotS$avg) > 1000){ #adjust plotting based on scale of spawnersf
    axis(2, tick = T, at = format(c(-100 * min(plotS$avg), pretty(plotS$avg, n = 3),
                                    2 * max(plotS$avg)), digits = 2, nsmall = 0),
         mgp = c(3, 0.6, 0), las = 0)
    mtext(side = 2, line = 2.5, 'Escapement or Catch', cex = 1.2)
  }
  if(mean(plotS$avg) < 1000){
    axis(2, tick = T, at = round(c(-100 * min(plotS$avg), pretty(plotS$avg, n = 3),
                                   2 * max(plotS$avg)), digits = 1),
         mgp = c(3, 0.6, 0), las = 0)
    mtext(side = 2, line = 2.5, 'Escapement or Catch (millions)', cex = 1.2)
  }
  par(new = T)
  plot(plotExt$avg ~ plotER, type = "l", axes = F, col = extCol, lty = 2, lwd = 1.25,
       xlab = "", ylab="", ylim = c(0, 1))
  shade(rbind(plotExt$lowQ, plotExt$highQ), plotER, col = alpha(extCol, 0.3))
  lines(plotUpperBM$avg ~ plotER, xaxt="n", yaxt="n", type="l", lty = 2, lwd = 1.25,
        col = bmCol)
  shade(rbind(plotUpperBM$lowQ, plotUpperBM$highQ), plotER, col = alpha(bmCol, 0.3))
  axis(4, tick = T, at = c(-1, 0.0, 0.5, 1, 2), las = 0, mgp = c(3, 0.6, 0))
  # technicolorTitle(words = c("Proportions of CUs" , "Extinct"), colours = c("black", extCol),
  #                  cex = 1.25, side = 4, line = 2.25)
  # technicolorTitle(words = c("or" , "Above Lower BM"), colours = c("black", bmCol),
  #                  cex = 1.25, side = 4, line = 3.25)
  mtext(side = 4, line = 3, 'Proportion of CUs Extinct \n or Above Upper BM', cex = 1.2)
  axis(3, tick = T, at = c(-0.2, 1.2), mgp = c(3, 0.6, 0))
}


#___________________________________________________________________________________________________________
# This function plots time series of aggregate PMs with or without uncertainty (based on B. Connors Atnarko figure)
plotAggTS <- function(datList, vars, uncertainty = FALSE, showTrials = FALSE,
                      axisSize = 15, dotSize = 3.5, lineSize = 0.8, legendSize = 14) {
  for (h in seq_along(vars)) {
    simLength <- datList[[1]]$`nYears`
    nPrime <- datList[[1]]$`nPrime`
    startYr <- datList[[1]]$`firstYr`
    # figTitle <- datList[[1]]$`opMod`
    dum <- data.frame(keyVar = rep(as.vector(sapply(datList, function(x) unique(x$keyVar))),
                                   each = simLength),
                      hcr = rep(as.vector(sapply(datList, function(x) unique(x$hcr))),
                                each = simLength),
                      year = rep(seq(from = startYr, to = (startYr + simLength - 1)),
                                     times = length(datList)),
                      med = as.vector(sapply(datList, function(x) {
                        apply(data.frame(x[vars[h]]), 1, median)
                        })),
                      lowQ = as.vector(sapply(datList, function(x) {
                        apply(data.frame(x[vars[h]]), 1, qLow)
                        })),
                      highQ = as.vector(sapply(datList, function(x) {
                        apply(data.frame(x[vars[h]]), 1, qHigh)
                        }))
                      )
    if (showTrials == TRUE) { #plot 3 random trials rather as well as medians across trials to show variation
      trials <- NULL
      for (i in 1:length(datList)) {
        temp <- data.frame(datList[[i]][vars[h]])
        temp2 <- temp[, sample(ncol(temp), size = 3, replace = FALSE), ]
        names(temp2)[1:3] <- c("simX1", "simX2", "simX3")
        trials <- rbind(trials, temp2)
      }
      dum <- cbind(dum, trials)
      # dum[ , 7:9] <- trials
    }
    dum <- dum[order(dum$hcr, dum$keyVar),]
    dum$keyVar <- as.character(dum$keyVar)
    # dum$facER <- ifelse(dum$hcr == "TAM",
    #                     "TAM",
    #                     as.character(dum$targetER))
    dum$keyVar <- ifelse(dum$year <= (startYr + nPrime - 1), "historic",
                         dum$keyVar)
    dum$keyVar <- as.factor(dum$keyVar)
    colPal <- viridis(length(datList), begin = 0, end = 1)
    colPal <- c(colPal, "black")
    names(colPal) <- levels(dum$keyVar)
    dum <- subset(dum, year > 1979)
    yLabel <- vars[h]
    if (uncertainty == FALSE) {
      p <- ggplot(dum, aes(x = year, y = med, colour = keyVar)) +
        labs(x = "Year", y = yLabel) +
        geom_line(size = 1) +
        scale_colour_manual(name = "OpMod/ManProc", values = colPal) +
        theme_sleek() +
        theme(axis.text = element_text(size = 0.95 * axisSize),
              axis.title = element_text(size = axisSize),
              legend.text = element_text(size = 0.95 * legendSize),
              legend.title = element_text(size = legendSize))
      if (showTrials == TRUE) {
        p <- p +
          geom_line(data = dum, aes(x = year, y = simX1, colour = keyVar), size = 0.55 * lineSize) +
          geom_line(data = dum, aes(x = year, y = simX2, colour = keyVar), size = 0.55 * lineSize) +
          geom_line(data = dum, aes(x = year, y = simX3, colour = keyVar), size = 0.55 * lineSize)
      }
      print(p)
    }
    if (uncertainty == TRUE) {
      if (length(unique(dum$targetER)) > 3) {
        trimDum <- subset(dum, targetER == min(dum$targetER) | targetER == median(dum$targetER)
                          | targetER == max(dum$targetER))
      } else {
        trimDum <- dum
      }
      p <- ggplot(trimDum, aes(x = year, y = med, colour = keyVar)) +
        labs(x = "Year", y = yLabel) +
        geom_line(size = 1) +
        geom_ribbon(data = trimDum, aes(ymin = lowQ, ymax = highQ, fill = keyVar),
                    alpha = 0.3) +
        scale_colour_manual(name = "Exp. Rate", values = colPal) +
        scale_fill_manual(name = "Exp. Rate", values = colPal) +
        theme_sleek() +
        theme(axis.text = element_text(size = 0.95 * axisSize),
              axis.title = element_text(size = axisSize),
              legend.text = element_text(size = 0.95 * legendSize),
              legend.title = element_text(size = legendSize))
      if (showTrials == TRUE) {
        p <- p +
          geom_line(data = trimDum, aes(x = year, y = simX1, colour = keyVar), size = 0.55 * lineSize) +
          geom_line(data = trimDum, aes(x = year, y = simX2, colour = keyVar), size = 0.55 * lineSize) +
          geom_line(data = trimDum, aes(x = year, y = simX3, colour = keyVar), size = 0.55 * lineSize)
      }
      print(p)
    }
  }
}


#___________________________________________________________________________________________________________
# This function plots time series of true variables across different operating models; if obsVar is passed and
# error = TRUE compares errors associated with observation or outcome uncertainty. Error bands added w/
# uncertainty = TRUE. Also prints median variation (SD) estimates for plotted variables.

plotOpmodTS <- function(datList, trueVar, obsVar = NULL, legendCaptions = NULL,
                        yAxisLab = NULL, uncertainty = FALSE, error = FALSE,
                        figName = NULL, axisSize = 15, lineSize = 0.8, legendSize = 14) {
  if (error == TRUE & is.null(obsVar)) {
    stop("Provide observation variable to calculate errors")
  }
  nYears <- datList[[1]]$`nYears`
  simLength <- datList[[1]]$`nYears` - datList[[1]]$`nPrime`
  firstYear <- datList[[1]]$`firstYr`
  start <- datList[[1]]$`nPrime` + firstYear
  datListTrim <- lapply(datList, function (x) {
    trueMat <- matrix(unlist(x[trueVar]), nrow = nYears)
    if (error == TRUE) {
      obsMat <- matrix(unlist(x[obsVar]), nrow = nYears)
      errDat <- (obsMat - trueMat) / trueMat
      return(errDat)
    } else {
      return(trueMat)
    }
  })
  dum <- data.frame(om = rep(as.vector(sapply(datList, function(x) unique(x$opMod))),
                             each = nYears),
                    plotOrder = rep(as.vector(sapply(datList, function(x) unique(x$plotOrder))),
                                    each = nYears),
                    year = rep(seq(from = firstYear, to = (firstYear + nYears - 1)),
                               times = length(datList)),
                    med = as.vector(sapply(datListTrim, function(x) {
                      apply(x, 1, median)
                    })),
                    lowQ = as.vector(sapply(datListTrim, function(x) {
                      apply(x, 1, qLow)
                    })),
                    highQ = as.vector(sapply(datListTrim, function(x) {
                      apply(x, 1, qHigh)
                    }))
  )
  dum$om <- as.character(dum$om)
  dum[dum$year < start, ]$om <- "obs"
  dum$om <- factor(dum$om, levels = unique(dum$om[order(dum$plotOrder)]),
                   ordered = TRUE)
  if (is.null(legendCaptions) == FALSE) {
    levels(dum$om) <- legendCaptions
  }
  # stdDev <- sapply(datListTrim, function(x) sd(x, na.rm = T))
  # outputTable <- c(trueVar, stdDev)
  colPal <- c("black", viridis(length(datList), begin = 0, end = 1))
  names(colPal) <- levels(dum$om)
  if (error == TRUE) {
    yLabel <- ifelse(is.null(yAxisLab) == FALSE,
                     yAxisLab,
                     paste(trueVar, "Error", sep = " "))
  } else {
    yLabel <- ifelse(is.null(yAxisLab) == FALSE,
                     yAxisLab,
                     trueVar)
  }
  p <- ggplot(dum, aes(x = year, y = med, colour = om)) +
    labs(x = "Year", y = yLabel, title = figName) +
    geom_line(size = 1) +
    geom_vline(xintercept = start, color = "black", linetype = 3, size = 1) +
    scale_colour_manual(name = "Op. Model", values = colPal) +
    theme_sleek() +
    theme(axis.text = element_text(size = 0.95 * axisSize),
          axis.title = element_text(size = axisSize),
          legend.text = element_text(size = 0.95 * legendSize),
          legend.title = element_text(size = legendSize))
  if (uncertainty == FALSE) {
    return(p)
  }
  if (uncertainty == TRUE) {
    q <- p +
      geom_ribbon(data = dum, aes(ymin = lowQ, ymax = highQ, fill = om),
                  alpha = 0.3) +
      scale_fill_manual(name = "Op. Model", values = colPal)
    return(q)
  }
}


#___________________________________________________________________________________________________________
# This function plots time series of abundance using arrays saved in synchList objects; originally
# intended to be used to assess how well different OMs recreate historical population dynamics
plotTSByCU <- function(datList, var, plotACF = FALSE) {
  opMod <- datList[["nameOM"]]
  dat <- datList[[var]]
  nCU <- dim(dat)[2]
  colVec <- viridis(nCU, begin = 0, end = 1)
  primePeriod <- 1:datList[["nPrime"]]
  simPeriod <- datList[["nPrime"]]:dim(dat)[1]
  set.seed(789)
  trialSeq <- sample.int(dim(dat)[3], size = 8)
  maxY <- max(dat[ , , trialSeq], na.rm = TRUE)
  minY <- min(dat[ , , trialSeq], na.rm = TRUE)

  par(mfrow = c(3, 3), mar = c(3,2,0.75,0.75), oma = c(0,2,2,0))
  plot(1, type = "n", ylab = "", xlab = "", xlim = c(0.5, max(primePeriod)),
       ylim = c(minY, maxY))
  text(0.95 * max(primePeriod), 0.95 * max(dat[ , , trialSeq], na.rm = TRUE),
       "Obs")
  for (k in 1:nCU) {
    lines(dat[primePeriod, k, 1], type = "l",  col = colVec[k])
  }
  for (h in seq_along(trialSeq)) {
    plot(1, type = "n", ylab = "", xlab = "", xlim = c(0.5, max(primePeriod)),
         ylim = c(minY, maxY))
    for (k in 1:nCU) {
      lines(dat[simPeriod, k, trialSeq[h]], type = "l",  col = colVec[k])
    }
    text(0.95 * max(primePeriod), 0.95 * max(dat[ , , trialSeq], na.rm = TRUE),
         trialSeq[h])
  }
  mtext(opMod, side = 3, line = 0.25, outer = TRUE)
  mtext(var, side = 2, line = 0.5, outer = TRUE)
  if (plotACF == TRUE) {
    primeDat <- ifelse(rep(var == "logRS", length.out = length(primePeriod)),
                       apply(dat[primePeriod, , 1], 1, function (t) mean(t, na.rm = T)),
                       rowSums(dat[primePeriod, , 1], na.rm = TRUE))
    acf(primeDat)
    text(0.95 * max(primePeriod), 0.95 * max(dat[ , , trialSeq], na.rm = TRUE),
         "Obs")
    for (h in seq_along(trialSeq)) {
      simDat <- ifelse(rep(var == "logRS", length.out = length(primePeriod)),
                       apply(dat[simPeriod, , trialSeq[h]], 1, function (t) mean(t, na.rm = T)),
                       rowSums(dat[simPeriod, , trialSeq[h]]))
      acf(simDat)
      text(0.95 * max(primePeriod), 0.95 * max(dat[ , , trialSeq], na.rm = TRUE),
           trialSeq[h])
    }
  }
  mtext(opMod, side = 3, line = 0.25, outer = TRUE)
  mtext(paste("Aggregate", var, sep = " "), side = 2, line = 0.5, outer = TRUE)
}



#___________________________________________________________________________________________________________


### CURRENTLY UNUSED FUNCTIONS ###
# #___________________________________________________________________________________________________________
# # This plotting function is similar to ppnDotPlotMP and OM, but accepts current PM status
# # for comparison purposes and is less well suited to automation
# takeHomeDot <- function(datList, vars, presDat, agg = TRUE,
#                         axisSize = 15, dotSize = 3.5, lineSize = 0.8, legendSize = 14){
#   #make directory if necessary
#   if (agg == TRUE) {
#     fileName <- paste(subDirName, "AgCleanPlot.pdf", sep = "/")
#
#     #clean agg data
#     hcr <- sapply(datList, function(x) unique(x$hcr))
#     er <- sapply(datList, function(x) mean(x$targetER))
#     plotDat = NULL
#     for (i in seq_along(vars)) {
#       dum <- data.frame(var = rep(vars[i], length.out = length(datList)),
#                         hcr = hcr,
#                         er = er,
#                         avg = sapply(datList, function(x) median(x[, vars[i]])),
#                         lowQ = sapply(datList, function(x) qLow(x[, vars[i]])),
#                         highQ = sapply(datList, function(x) qHigh(x[, vars[i]]))
#       )
#       dum <- dum[order(dum$hcr, dum$er),]
#       plotDat <- rbind(plotDat, dum)
#     }
#     plotDat$colAlpha <- rep(seq(from = 0.25, to = 1, length = length(datList)),
#                             length.out = nrow(plotDat)) #vector to fade based on ER
#     plotDat$sym <- ifelse(plotDat$hcr == "fixedER", 21, 25)
#     if (length(levels(dum$hcr)) > 1) {
#       plotDat[plotDat$hcr == "TAM", ]$er <- "TAM"
#     }
#     rownames(plotDat) <- c()
#
#     #generate plots
#     pdf(paste(here("outputs/summaryFigs"), dirName, fileName, sep = "/"),
#         height = 5, width = 5)
#     sapply(seq_along(vars), function(i) {
#       d <- subset(plotDat, var == vars[i])
#       currentStatus <- subset(presDat, stkNumber == "agg")[ , vars[i]] #extract current status for relevant PM
#       p <- ggplot(d, aes(factor(er), y = avg, ymin = lowQ, ymax = highQ)) +
#         labs(x = "Harvest Control Rule", y = vars[i]) +
#         geom_pointrange(alpha = d$colAlpha, shape = d$sym, fill = "black",
#                         size = lineSize, fatten = dotSize) +
#         geom_hline(yintercept = currentStatus, colour = "red", size = 2) +
#         theme_sleek() +
#         theme(strip.text = element_text(size = axisSize),
#               axis.text = element_text(size = 0.95 * axisSize),
#               axis.title = element_text(size = axisSize),
#               legend.text = element_text(size = 0.95 * legendSize),
#               legend.title = element_text(size = legendSize))
#       print(p)
#     })
#     dev.off()
#   }
#
#   #Cu-specific plots
#   if (agg == FALSE) {
#     fileName <- paste(subDirName, "CuCleanPlot.pdf", sep = "/")
#
#     nCU <- length(datList[[1]]$stkName)
#     hcr <- rep(as.vector(sapply(datList, function(x) x$hcr)), each = nCU)
#     cu <- as.vector(sapply(datList, function(x) x$stkName))
#     stkNumber <- as.vector(sapply(datList, function(x) x$stkNumber)) #necessary to index w/ presDat
#     er <- as.vector(sapply(datList, function(x) apply(x$targetER, 2, mean)))
#
#     #clean and generate plots
#     pdf(paste(here("outputs/summaryFigs"), dirName, fileName, sep = "/"),
#         height = 6, width = 8)
#     for (i in seq_along(vars)) {
#       presStatus <- presDat[, c("stkNumber", vars[i])] #extract current status for relevant PM
#       names(presStatus)[2] <- "pres"
#       dum <- data.frame(hcr = hcr,
#                         cu = cu,
#                         stkNumber = stkNumber,
#                         var = rep(vars[i], length.out = nCU * length(datList)),
#                         er = er,
#                         avg = as.vector(sapply(datList, function(x) {
#                           apply(data.frame(x[names(x) %in% vars[i]]), 2, median)
#                         })),
#                         lowQ = as.vector(sapply(datList, function(x) {
#                           apply(data.frame(x[names(x) %in% vars[i]]), 2, qLow)
#                         })),
#                         highQ = as.vector(sapply(datList, function(x) {
#                           apply(data.frame(x[names(x) %in% vars[i]]), 2, qHigh)
#                         }))
#       )
#       dum <- merge(dum, presStatus, by = "stkNumber")
#       if (length(levels(dum$hcr)) > 1) {
#         dum[dum$hcr == "TAM", ]$er <- "TAM"
#       }
#       dum$sym <- ifelse(dum$hcr=="fixedER", 21, 25)
#       dum <- dum[order(dum$var, dum$cu, dum$er),]
#       dum$alp <- rep(seq(from = 0.25, to = 1, length.out = length(unique(er))), nCU)
#
#       p<-ggplot(dum, aes(factor(er), y = avg, ymin = lowQ, ymax = highQ)) +
#         labs(x = "Harvest Control Rule", y = vars[i]) +
#         geom_pointrange(alpha = dum$alp, shape = dum$sym, fill = "black",
#                         size = lineSize, fatten = dotSize) +
#         geom_hline(data = dum, aes(yintercept = pres), colour = "red", size = 2) +
#         theme_sleek() +
#         theme(strip.text = element_text(size = axisSize),
#               axis.text = element_text(size = 0.95 * axisSize),
#               axis.title = element_text(size = axisSize),
#               legend.text = element_text(size = 0.95 * legendSize),
#               legend.title = element_text(size = legendSize)) +
#         facet_wrap(~ cu)
#       print(p)
#     } # finish for (i in seq_along(vars))
#     dev.off()
#   } #finish if agg == FALSE
# } #end function
#


# #___________________________________________________________________________________________________________
# # This function gathers aggregate output data from the relevant directories and subdirectories
# makeAgList <- function(dirName, subDirName){
#   listNames <- list.files(paste(here("outputs/simData"), dirName, subDirName, sep="/"), pattern="*aggDat.csv")
#   aggList <- list()
#   for(i in 1:length(listNames)){
#     aggList[[i]] <- read.csv(paste(here("outputs/simData"), dirName, subDirName, listNames[i], sep="/"))
#   }
#   names(aggList) <- listNames
#   return(aggList)
# }
#
#
# #___________________________________________________________________________________________________________
# # This function plots multi-color text labels
# technicolorTitle <- function(words, colours, cex = 1, side, line) {
#   widths <- strwidth(words, cex = cex)
#   spaces <- rep(strwidth(" ", cex = cex), length(widths) - 1)
#   middle <- mean(par("usr")[1:2])
#   total <- sum(widths) + sum(spaces)
#   start <- c(0, cumsum(widths[-length(widths)] + spaces))
#   start <- start + middle - (total / 2)
#   mtext(words, side, line, at = start, adj = 0, col = colours, cex = cex)
# }
#


#___________________________________________________________________________________________________________
# This function generates tradeoff figures comparing different OMs based on output from makeAgList;
# kept the two functions separate to allow for combinations of different simulation runs
# When creating pub quality figs will need to move legend to outer margin, which will complicate looping
# See commented out section for details
# compareOMsPlot <- function(listAggLists, omNames, catchVars, consVars, dirName,
#                          showUncertainty = FALSE){
#   #make data frame for each OM
#   fullDat <- NULL
#   omCols <- viridis(length(omNames), begin = 0, end = 1)
#   for(h in 1:length(listAggLists)){
#     aggList <- listAggLists[[h]]
#     plotDat <- NULL
#     vars = c(catchVars, consVars)
#     index = c(rep("catch", length.out = length(catchVars)), rep("cons", length.out = length(consVars)))
#     # hcr <- unlist(sapply(aggList, function(x) unique(as.character(x$hcr))))
#     hcr <- sapply(aggList, function(x) unique(x$hcr))
#     er <- sapply(aggList, function(x) mean(x$targetER))
#     for(i in seq_along(vars)){
#       dum <- data.frame(om = rep(omNames[h], length.out = length(aggList)),
#                         var = rep(vars[i], length.out = length(aggList)),
#                         type = rep(index[i], length.out = length(aggList)),
#                         hcr = hcr,
#                         er = er,
#                         avg = sapply(aggList, function(x) median(x[,vars[i]])),
#                         lowQ = sapply(aggList, function(x) qLow(x[,vars[i]])),
#                         highQ = sapply(aggList, function(x) qHigh(x[,vars[i]]))
#       )
#       dum <- dum[order(dum$hcr, dum$er),]
#       plotDat <- rbind(plotDat, dum)
#     }
#     rownames(plotDat) <- c()
#     plotDat$colAlpha <- rep(seq(from = 0.2, to = 1, length = length(unique(plotDat$er))), length.out = nrow(plotDat)) #vector to fade based on ER
#     plotDat$col <- omCols[h]
#     fullDat <- rbind(fullDat, plotDat)
#   }
#   fullDat$sym <- ifelse(fullDat$hcr=="fixedER", 21, 25)
#   fullDat$er <- ifelse(fullDat$hcr=="fixedER", plotDat$er, "TAM")
#
#   # subset data to pass to plotting function
#   catchDat <- fullDat[fullDat$type=="catch",]
#   consDat <- fullDat[fullDat$type=="cons",]
#
#   pdf(file = paste(here("outputs/simData"), dirName, "omAgFig.pdf", sep="/"), height = 6, width = 7)
#   for(h in seq_along(catchVars)){ #for each catch variable
#     par(mfrow = c(2,2), mar = c(1,4,1.25,0.5), oma = c(4,0,2,0), cex.lab = 1)
#     catchTrim <- catchDat[catchDat$var==catchVars[h],]
#     for(i in seq_along(consVars)){
#       consTrim <- consDat[consDat$var==consVars[i],]
#       if(showUncertainty==FALSE){
#         plot(consTrim$avg~catchTrim$avg, pch = consTrim$sym,
#              bg = alpha(consTrim$col, consTrim$colAlpha), ylab="", xlab="",
#              cex = 1.5)
#       }
#       if(showUncertainty==TRUE){
#         tradeoffPlot(catchTrim$avg, consTrim$avg, catchTrim$range, consTrim$range, cols = consTrim$col,
#                      colAlpha = consTrim$colAlpha, pch = consTrim$sym, cex = 1.5)
#       }
#       mtext(side = 2, line = 2.5, print(consVars[i]))
#       if(i==1 | i==5 | i==9){
#         mtext(side = 1, line = 1.5, catchVars[h], outer = TRUE)
#         mtext(side = 3, line = 0.25, dirName, outer = TRUE, cex = 1.2)
#         legend("topright", legend = unique(consTrim$om), ncol = 2, bg="transparent",
#                pt.bg = unique(consTrim$col), cex = 1, pch = consTrim$sym)
#       }
#     }
#   }
#   dev.off()
# }




# plotCUCatchTradeOffs <- function(cuList, nCU, catchVars, consVars, showUncertainty = FALSE,
#                                  wrap = "CU", axisSize = 14, dotSize = 3, lineSize = 1.5,
#                                  legendSize = 14) {
#   #save index variables
#   colPal <- viridis(nCU, begin = 0, end = 1)
#   vars = c(catchVars, consVars)
#   hcr <- rep(as.vector(sapply(cuList, function(x) x$hcr)), each = nCU)
#   cu <- as.vector(sapply(cuList, function(x) x$stkName))
#   mu <- as.vector(sapply(cuList, function(x) x$manUnit))
#   # er <- as.vector(sapply(cuList, function(x) apply(x$targetER, 2, mean)))
#   keyVar <- rep(as.vector(sapply(cuList, function(x) x$keyVar)), each = nCU)
#   plotOrder <- rep(as.vector(sapply(cuList, function(x) x$plotOrder)), each = nCU)
#   lowCatchVars <- paste("low", catchVars, sep = "_") #index for looping
#   lowConsVars <- paste("low", consVars, sep = "_") #index for looping
#   highCatchVars <- paste("high", catchVars, sep = "_") #index for looping
#   highConsVars <- paste("high", consVars, sep = "_") #index for looping
#   #make a dataframe of CU-specific means across trials
#   plotDat <- NULL
#   for (j in seq_along(vars)) {
#     dum <- data.frame(hcr = hcr,
#                       cu = cu,
#                       mu = mu,
#                       var = rep(vars[j], length.out = nCU * length(cuList)),
#                       # er = er,
#                       keyVar = as.factor(keyVar),
#                       plotOrder = plotOrder,
#                       avg = as.vector(sapply(cuList, function(x) {
#                         apply(data.frame(x[names(x) %in% vars[j]]), 2, median)
#                       })),
#                       lowQ = as.vector(sapply(cuList, function(x) {
#                         apply(data.frame(x[names(x) %in% vars[j]]), 2, qLow)
#                       })),
#                       highQ = as.vector(sapply(cuList, function(x) {
#                         apply(data.frame(x[names(x) %in% vars[j]]), 2, qHigh)
#                       }))
#     )
#     plotDat <- rbind(plotDat, dum)
#   }
#   plotDat$mu <- factor(plotDat$mu, levels = c("EStu", "ESumm", "Summ", "Lat"))
#   plotDat$hcr <- factor(plotDat$hcr, levels = c("fixedER", "TAM"))
#   plotDat$key <- paste(plotDat$cu, plotDat$mu, plotDat$keyVar, sep="_")
#   # have to peel off and recombine quantiles to make plottable DF; sloppy but unsure how else to do it
#   plotAvg <- plotDat %>% select(-lowQ, -highQ) %>% spread(var, avg)
#   plotLow <- plotDat %>% select(key, var, lowQ) %>% spread(var, lowQ)
#   names(plotLow)[2:ncol(plotLow)] <- paste("low", names(plotLow)[2:ncol(plotLow)], sep="_")
#   plotHigh <- plotDat %>% select(key, var, highQ) %>% spread(var, highQ)
#   names(plotHigh)[2:ncol(plotHigh)] <- paste("high", names(plotHigh)[2:ncol(plotHigh)], sep="_")
#   temp <- Reduce(function(x, y) merge(x, y, by = "key"), list(plotAvg, plotLow, plotHigh))
#   plotD <- subset(temp, select = -c(key))
#
#   # Plot
#   for (h in seq_along(catchVars)) { #iterate across catch variables
#     for (i in seq_along(consVars)) { #iterate across catch variables
#       dum <- plotD %>%
#         select(hcr, cu, mu, keyVar, catchVar = catchVars[h], consVar = consVars[i],
#                lowCatch = lowCatchVars[h], lowCons = lowConsVars[i],
#                highCatch = highCatchVars[h], highCons = highConsVars[i])
#       p <- ggplot(dum, aes(x = catchVar, y = consVar, shape = hcr, alpha = keyVar,
#                            fill = cu)) +
#         geom_point(size = dotSize) +
#         theme_sleek() +
#         theme(strip.text = element_text(size = axisSize),
#               axis.text = element_text(size = 0.9 * axisSize),
#               axis.title = element_text(size = axisSize),
#               legend.text = element_text(size = 0.9 * legendSize),
#               legend.title = element_text(size = legendSize)) +
#         xlab(catchVars[h]) +
#         ylab(consVars[i]) +
#         scale_shape_manual(values = c(21, 25), name = "Control Rule") +
#         scale_alpha_discrete(range = c(0.3, 1), name = "Man. Proc.")  +
#         scale_fill_manual(values = colPal, name = "CU")
#       if (length(unique(dum$hcr)) == 1) {
#         p <- p +
#           guides(shape = "none")
#       } else {
#         p <- p +
#           guides(shape = guide_legend(override.aes = list(fill = "black")))
#       }
#       if (wrap == "MU") {
#         p <- p +
#           facet_wrap(~mu, scales = "free") +
#           guides(fill = guide_legend(override.aes = list(shape = 21, colour = "black",
#                                                          fill = colPal)))
#       }
#       if (wrap == "CU") {
#         p <- p +
#           facet_wrap(~cu, scales = "free") +
#           guides(fill = FALSE)
#       }
#       if (showUncertainty == FALSE) {
#         print(p)
#       }
#       if (showUncertainty==TRUE) {
#         q <- p +
#           geom_errorbar(aes(ymin = lowCons, ymax = highCons),
#                         alpha = 0.3, width = 0, size = lineSize) +
#           geom_errorbarh(aes(xmin = lowCatch, xmax = highCatch),
#                          alpha = 0.3, height = 0, size = lineSize)
#         print(q)
#       }
#     } #end conservation variable subset
#   } #end catch variable subset
# }
