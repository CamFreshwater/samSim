#*************************************************************************************
# runModel.R
# Date revised: ONGOING
# Inputs: SimpleSimWCatch.R
# Outputs: pdf plots, matrices for plotting
# Explainer: Runs closed loop simulation model with different OMs and MPs based on
#           input csv files
#*************************************************************************************

# setwd("/Users/cam/github/salmon-sim") #Cam's Mac wd
setwd("C:/github/salmon-sim/")


# Check if required packages are installed and run
listOfPackages <- c("plyr", "here", "parallel", "doParallel", "foreach", "reshape2", "tidyr",
                    "gsl", "tictoc", "stringr", "dplyr", "synchrony", "zoo", "Rcpp", 
                    "RcppArmadillo")
newPackages <- listOfPackages[!(listOfPackages %in% installed.packages()[ , "Package"])]
if (length(newPackages)) {
  install.packages(newPackages)
}
lapply(listOfPackages, require, character.only = TRUE)


source(here("scripts/func/postProcessing.R"))
source(here("scripts/recoverySim.R"))


simPar <- read.csv(here("data/fraserSimInputs.csv"), stringsAsFactors=F)
cuPar <- read.csv(here("data/fraserCUpars.csv"), stringsAsFactors=F)
srDat <- read.csv(here("data/fraserRecDatTrim.csv"), stringsAsFactors=F)
catchDat <- read.csv(here("data/fraserCatchDatTrim.csv"), stringsAsFactors=F)
ricPars <- read.csv(here("data/fraserDat/rickerMCMCPars.csv"), stringsAsFactors=F)
larkPars <- read.csv(here("data/fraserDat/larkinMCMCPars.csv"), stringsAsFactors=F)
tamFRP <- read.csv(here("data/fraserDat/tamRefPts.csv"), stringsAsFactors=F)
# simPar <- read.csv(here("data/nassSimInputs.csv"), stringsAsFactors=F)
# cuPar <- read.csv(here("data/nassCUpars.csv"), stringsAsFactors=F)
# srDat <- read.csv(here("data/nassRecDatTrim.csv"), stringsAsFactors=F)
# catchDat <- read.csv(here("data/nassCatchDatTrim.csv"), stringsAsFactors=F)
# ricPars <- read.csv(here("data/northCoastDat/nassChumMCMCPars.csv"), stringsAsFactors=F)


### SET UP MODEL RUN -----------------------------------------------------

## Define simulations to be run
nTrials <- 10

simParTrim <- subset(simPar, scenario == "staticTAM" | scenario == "varyTAM")
scenNames <- unique(simParTrim$scenario)
dirNames <- sapply(scenNames, function(x) paste(x, unique(simParTrim$species), sep = "_"))

# for (h in 1:nrow(simParTrim)) {
#   recoverySim(simParTrim[h,], cuPar, catchDat = catchDat, srDat = srDat, variableCU = FALSE, 
#                     ricPars, larkPars = larkPars, tamFRP = tamFRP, 
#                     dirName = paste(simParTrim[h,]$scenario, simParTrim[h,]$species, sep = "_"), 
#                     nTrials = nTrials, multipleMPs = FALSE)
# }
# recoverySim(simParTrim[1,], cuPar, catchDat = catchDat, srDat = srDat, variableCU = FALSE,
#                   ricPars, larkPars = larkPars, tamFRP = tamFRP, cuCustomCorrMat = cuCustomCorrMat,
#                     dirName = dirNames[1], nTrials = 5, multipleMPs = FALSE)

for (i in seq_along(dirNames)) {
  dirName <- dirNames[i]
  d <- subset(simParTrim, scenario == scenNames[i])
  simsToRun <- split(d, seq(nrow(d)))
  Ncores <- detectCores()
  cl <- makeCluster(Ncores - 2) #save two cores
  registerDoParallel(cl)
  clusterEvalQ(cl, c(library(MASS),
                  library(here),
                  library(sensitivity),
                  library(mvtnorm),
                  library(scales), #shaded colors for figs
                  library(here), #use this package so wd are common across different computers
                  library(synchrony),
                  library(zoo), #synch and zoo used to calculate rolling estimates of synchrony
                  library(viridis), #color blind gradient palette
                  library(ggplot2),
                  library(gsl), #to calculate exact estimate of MSY following Scheuerell 2016 PeerJ
                  library(dplyr),
                  library(Rcpp),
                  library(RcppArmadillo)))
  if(simsToRun[[1]]$species == "sockeye"){
    clusterExport(cl, c("simsToRun","recoverySim","cuPar","dirName","nTrials","catchDat","srDat",
                       "ricPars","dirName","larkPars","tamFRP"), envir=environment()) #export custom function and objects
    tic("run in parallel")
    parLapply(cl, simsToRun, function(x) {
      recoverySim(x, cuPar, catchDat=catchDat, srDat=srDat, variableCU=FALSE, 
                  ricPars, larkPars=larkPars, tamFRP=tamFRP, dirName=dirName, 
                  nTrials=nTrials, multipleMPs=TRUE)
      })
    stopCluster(cl) #end cluster
    toc()
  }
  if(simsToRun[[1]]$species == "chum"){
    clusterExport(cl, c("simsToRun","recoverySim","cuPar","dirName","nTrials","catchDat","srDat",
                       "ricPars","dirName"), envir = environment()) #export custom function and objects
    tic("run in parallel")
    parLapply(cl, simsToRun, function(x) {
      recoverySim(x, cuPar, catchDat=catchDat, srDat=srDat, variableCU=FALSE, 
                  ricPars, larkPars=NULL, tamFRP=NULL, dirName=dirName, 
                  nTrials=nTrials, multipleMPs=TRUE)
      })
    stopCluster(cl) #end cluster
    toc()
  }
}


### GENERATE OUTPUT FIGS -------------------------------------------------
source(here("scripts/func/postProcessing.R"))

## Read in data from directory folder
subDirs <- list.dirs(path = paste(here("outputs/simData"), dirName, sep = "/"), full.names = FALSE, recursive = FALSE) #alternatively ID OMs based on prespecified directory
## Generate figures
if (simsToRun[[1]]$species == "sockeye") {
  selectedCUs <- c("E.St", "Bwrn", "Chlk", "L.Sh", "Clts", "Hrrs")
  sapply(dirNames, function (x) genCuOutputFigs(x, subDirs[1],
                                               selectedCUs = selectedCUs))
}
if (simsToRun[[1]]$species == "chum") {
  sapply(subDirs, function (x) genCuOutputFigs(dirName, x))
}
sapply(subDirs, function (x) genAgOutputFigs(dirName, x)) #generate output figures grouped by OM


## Generate operating model proportion dot plots
ifelse(!dir.exists(paste(here("outputs/simData"), "compareOMs", dirName, sep = "/")), #create dir if it doesn't already exist
       dir.create(paste(here("outputs/simData"), "compareOMs", dirName, sep = "/")), 
       FALSE)

if (simsToRun[[1]]$species == "sockeye") {
  cuList <- genOutputList("compareOMs", dirName, selectedCUs = selectedCUs, agg = FALSE)
} else {
  cuList <- genOutputList("compareOMs", dirName, selectedCUs = NULL, agg = FALSE)
}
  
pdf(file = paste(here(),"outputs/summaryFigs", dirName, "cuOmDotPlots.pdf", sep = "/"), 
    height = 6, width = 7)
ppnDotPlotOM(cuList,
             vars = c("meanSpawners", "varSpawners", "meanCatch", "varCatch", 
                      "ppnYrsUpper", "ppnYrsLower", "ppnYrsEstUpper", "ppnYrsEstLower"
                      # , "meanObsRecRY", "ppnYrsCOS", "ppnYrsSingCatch"
                      ),
             agg = FALSE, axisSize = 15, dotSize = 4.5, lineSize = 0.8, legendSize = 14)
dev.off()
  
pdf(file = paste(here(),"outputs/summaryFigs", dirName, "agOmDotPlots.pdf", sep = "/"), 
    height = 6, width = 7)
agList <- genOutputList("compareOMs", dirName, agg = TRUE)
ppnDotPlotOM(agList,
             vars = c("ppnYrsUpper", "ppnYrsLower","ppnCUExtinct"
                      # , 
                      #  "ppnCUUpper", "ppnCULower", "ppnCUExtant", "meanSynch", "meanCor", 
                      # "meanProdSynch", "ppnYrsEstUpper", "ppnYrsEstLower", "ppnCUEstUpper",
                      # "ppnCUEstLower",
             ),
             agg = TRUE, axisSize = 15, dotSize = 4.5, lineSize = 0.8, legendSize = 14)
dev.off()



### PROPER NUMBER OF SIMS -------------------------------------------------
# What is minimum number of trials for key metrics to stabilize?

## Run model
dirName <- "test"
nTrials <- 5000
refRun <- split(simPar[c(1),], seq(nrow(simPar[c(1),]))) #vanilla reference run w/ moderate ER
tic("run not in parallel")
lapply(refRun, function(x) recoverySim(simPar=x, cuPar, catchDat=catchDat, srDat=srDat, variableCU=FALSE,
                                       ricPars=ricPars, larkPars=larkPars, tamFRP=tamFRP, dirName=dirName,
                                       nTrials=nTrials))
toc()


## Gather and plot aggregate PMs
listNames <- list.files(paste(here("outputs/simData"), dirName, "test", sep="/"), pattern="*.csv")
aggDat <- read.csv(paste(here("outputs/simData"), dirName, "test", listNames[1], sep="/"))

aggDatTrim <- aggDat %>% #subset agg dat to focus on key PMs
          dplyr::select(meanSpawners, meanCatch, meanSynch, ppnYrsUpper, ppnCULower,
                        ppnCUUpper, ppnCUExtinct)


sampleSize <- c(100, 250, 500, 1000, 1500)
draws <- seq(from=1, to=5, by=1)
longDat <- sampleSims(aggDatTrim, sampleSizeVec = sampleSize, drawVec = draws, aggregate = TRUE)

perfM <- unique(longDat$pm)
pdf(file=paste(here(),"outputs/miscSensitivity/minTrials/trialNumAggPM.pdf", sep="/"), 
    height=6, width=7)
for(i in seq_along(unique(longDat$pm))){
  d <- longDat[longDat$pm == perfM[i], ]
  p <- ggplot(aes(y=value, x=as.factor(nTrials), fill=as.factor(nDraw)), data=d) +
      geom_boxplot() +
      ggtitle(perfM[i]) +
      theme(legend.position="none")
  print(p)
}
dev.off()


## As above but with CU-specific PMs
dfNames <- list.files(paste(here("outputs/simData"), dirName, "test", sep="/"), pattern="\\.RData$")
cuListIn <- readRDS(paste(here("outputs/simData"), dirName, "test", dfNames[1], sep="/"))
## Make new cu-specific list
stkNames <- cuListIn[["stkName"]]
cuList <- cuListIn[c("meanS", "sdS", "meanC", "ppnYrUpper", "ppnYrMixCatch")]
cuList <- lapply(cuList, function (x){
            y <- data.frame(x)
            names(y) <- stkNames
            return(y)
            # yTrim <- y[,c("E.St", "Bwrn", "Chlk", "Clts")] #drop most abundant 
            # return(yTrim)
})
sampleSize <- c(100, 250, 500, 1000, 1500)
draws <- seq(from=1, to=5, by=1)
newList <- lapply(cuList, function(x) sampleSims(as.data.frame(x), 
                                                 sampleSizeVec = sampleSize,
                                                 drawVec = draws, aggregate  = FALSE)
)

pdf(file=paste(here(),"outputs/miscSensitivity/minTrials/trialNumCuPM.pdf", sep="/"), 
    height=6, width=7)
sapply(seq(newList), function(j){
  p <- ggplot(aes(y=value, x=as.factor(nTrials), fill=as.factor(nDraw)), 
              data=newList[[j]]) +
        geom_boxplot() +
        ggtitle(names(cuList)[j]) +
        facet_wrap(~as.factor(cu)) +
        theme(legend.position="none")
  print(p)
})
dev.off()
