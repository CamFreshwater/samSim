#' Calculate synchrony metrics
#'
#' This function calculates rolling window estimates of several metrics related
#' to Thibaut and Connoly's (2013 Ecology Letters) analysis of aggregate
#' variability, including the synchrony index (phi), mean temporal coefficient
#' of variation among components (with weighting options), and mean pairwise
#' correlation coefficients. It is dependent on the \code{synchrony} package.
#' Contains multiple conditionals because computation can slows as the number
#' of time series, time series length, or the number of trials increase.
#'
#' @importFrom synchrony community.sync meancorr
#' @importFrom zoo rollapplyr
#'
#' @param synchList The output list \code{x_y_synchArrays.Rdata} generated by
#' \code{recoverySimulator.R} saved in the directory \code{outputs/simData/}.
#' @param windowSize A numeric representing the size of the moving window.
#' @param log A logical (defaults to FALSE) that determines whether the two
#' productivity metrics (model residuals and log(R/S)) should be logged prior
#' to calculating the synchrony metrics. Default is FALSE because estimates of
#' CV for variables centered on 0 are not interpretable.
#' @param synch A logical (defaults to TRUE) specifying whether the synchrony
#' metric phi should be calculated.
#' @param compCV A logical (defaults to TRUE) specifying whether mean component
#' CV should be calculated.
#' @param corr A logical (defaults to FALSE) specifying whether mean pairwise
#' correlation coefficients should be calculated (approximately equivalent to
#' phi).
#' @param weight A logical specifying whether compCV should be weighted by mean
#' abundance of recruits.
#' @return Returns a list containing three metrics (synchrony, component CV,
#' and mean pairwise correlation coefficient) for four simulation output time
#' series (recruits by brood year, log(R/S), SR model residuals, and spawner
#' abundance). Each list element is a matrix with dimensions nYears x nTrials.
#'
#' @examples
#' #relatively large number of trials so will take some time to run
#' calcSynchMetrics(synchList, windowSize = 10, log = FALSE, synch = TRUE,
#'                  compCV = TRUE, corr = FALSE, weight = TRUE)
#'
#' @export
calcSynchMetrics <- function(synchList, windowSize = 10, log = FALSE,
                             synch = TRUE, compCV = TRUE, corr = FALSE,
                             weight = TRUE) {
  spwn <- synchList$S
  recBY <- synchList$recBY
  if (log == TRUE) {
    resid <- synchList$recDev
    prod <- synchList$logRS
  } else {
    resid <- exp(synchList$recDev)
    prod <- exp(synchList$logRS)
  }
  migMort <- synchList$migMort
  nYears <- dim(recBY)[1]
  nTrials <- dim(recBY)[3]

  synchRecBY <- matrix(NA, nrow = nYears, ncol = nTrials)
  synchProd <- matrix(NA, nrow = nYears, ncol = nTrials)
  synchSpwn <- matrix(NA, nrow = nYears, ncol = nTrials)
  synchMort <- matrix(NA, nrow = nYears, ncol = nTrials)
  compCVRecBY <- matrix(NA, nrow = nYears, ncol = nTrials)
  compCVProd <- matrix(NA, nrow = nYears, ncol = nTrials)
  compCVSpwn <- matrix(NA, nrow = nYears, ncol = nTrials)
  compCVMort <- matrix(NA, nrow = nYears, ncol = nTrials)
  corrRecBY <- matrix(NA, nrow = nYears, ncol = nTrials)
  corrProd <- matrix(NA, nrow = nYears, ncol = nTrials)
  corrSpwn <- matrix(NA, nrow = nYears, ncol = nTrials)
  corrMort <- matrix(NA, nrow = nYears, ncol = nTrials)

  weightArray <- recBY
  wt <- TRUE
  if (weight == FALSE) {
    weightArray <- NULL
    wt <- FALSE
  }

  for (n in 1:nTrials) {
    if (synch == TRUE) {
      synchRecBY[ , n] <- rollapplyr(recBY[ , , n], width = windowSize,
                                     function(x) community.sync(x)$obs,
                                     fill = NA, by.column = FALSE)
      synchProd[ , n] <- rollapplyr(prod[ , , n], width = windowSize,
                                    function(x) community.sync(x)$obs,
                                    fill = NA, by.column = FALSE)
      synchSpwn[ , n] <- rollapplyr(spwn[ , , n], width = windowSize,
                                    function(x) community.sync(x)$obs,
                                    fill = NA, by.column = FALSE)
      synchMort[ , n] <- rollapplyr(migMort[ , , n], width = windowSize,
                                    function(x) community.sync(x)$obs,
                                    fill = NA, by.column = FALSE)
    }
    if (compCV == TRUE) {
      compCVRecBY[ , n] <- rollapplyr(recBY[ , , n], width = windowSize,
                                      function(x) wtdCV(x, weightMat = weightArray[ , , n],
                                                        weight = wt),
                                      fill = NA, by.column = FALSE)
      compCVProd[ , n] <- rollapplyr(prod[ , , n], width = windowSize,
                                     function(x) wtdCV(x, weightMat = weightArray[ , , n],
                                                       weight = wt),
                                     fill = NA, by.column = FALSE)
      compCVSpwn[ , n] <- rollapplyr(spwn[ , , n], width = windowSize,
                                     function(x) wtdCV(x, weightMat = weightArray[ , , n],
                                                       weight = wt),
                                     fill = NA, by.column = FALSE)
      compCVMort[ , n] <- rollapplyr(migMort[ , , n], width = windowSize,
                                     function(x) wtdCV(x, weightMat = weightArray[ , , n],
                                                       weight = wt),
                                     fill = NA, by.column = FALSE)
    }
    if (corr == TRUE) {
      corrRecBY[ , n] <- rollapplyr(recBY[ , , n], width = windowSize,
                                    function(x) meancorr(x)$obs,
                                    fill = NA, by.column = FALSE)
      corrProd[ , n] <- rollapplyr(prod[ , , n], width = windowSize,
                                   function(x) meancorr(x)$obs,
                                   fill = NA, by.column = FALSE)
      corrSpwn[ , n] <- rollapplyr(spwn[ , , n], width = windowSize,
                                   function(x) meancorr(x)$obs,
                                   fill = NA, by.column = FALSE)
      corrMort[ , n] <- rollapplyr(migMort[ , , n], width = windowSize,
                                   function(x) meancorr(x)$obs,
                                   fill = NA, by.column = FALSE)
    }
  }
  outputList <- list(synchRecBY, synchProd, synchSpwn, synchMort, compCVRecBY,
                     compCVProd, compCVSpwn, compCVMort, corrRecBY, corrProd,
                     corrSpwn, corrMort)
  names(outputList) <- c("synchRecBY", "synchProd", "synchSpwn", "synchMort",
                         "compCVRecBY", "compCVProd", "compCVSpwn", "compCVMort",
                         "corrRecBY", "corrProd", "corrSpwn", "corrMort")
  return(outputList)
}
